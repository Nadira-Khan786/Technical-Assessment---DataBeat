{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.draftjsToHtml = factory();\n})(this, function () {\n  'use strict';\n\n  /**\n  * Utility function to execute callback for eack key->value pair.\n  */\n  function forEach(obj, callback) {\n    if (obj) {\n      for (var key in obj) {\n        // eslint-disable-line no-restricted-syntax\n        if ({}.hasOwnProperty.call(obj, key)) {\n          callback(key, obj[key]);\n        }\n      }\n    }\n  }\n\n  /**\n  * The function returns true if the string passed to it has no content.\n  */\n  function isEmptyString(str) {\n    if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n  * Mapping block-type to corresponding html tag.\n  */\n  var blockTypesMapping = {\n    unstyled: 'p',\n    'header-one': 'h1',\n    'header-two': 'h2',\n    'header-three': 'h3',\n    'header-four': 'h4',\n    'header-five': 'h5',\n    'header-six': 'h6',\n    'unordered-list-item': 'ul',\n    'ordered-list-item': 'ol',\n    blockquote: 'blockquote',\n    code: 'pre'\n  };\n\n  /**\n  * Function will return HTML tag for a block.\n  */\n  function getBlockTag(type) {\n    return type && blockTypesMapping[type];\n  }\n\n  /**\n  * Function will return style string for a block.\n  */\n  function getBlockStyle(data) {\n    var styles = '';\n    forEach(data, function (key, value) {\n      if (value) {\n        styles += key + ':' + value + ';';\n      }\n    });\n    return styles;\n  }\n\n  /**\n  * The function returns an array of hashtag-sections in blocks.\n  * These will be areas in block which have hashtags applicable to them.\n  */\n  function getHashtagRanges(blockText, hashtagConfig) {\n    var sections = [];\n    if (hashtagConfig) {\n      var counter = 0;\n      var startIndex = 0;\n      var text = blockText;\n      var trigger = hashtagConfig.trigger || '#';\n      var separator = hashtagConfig.separator || ' ';\n      for (; text.length > 0 && startIndex >= 0;) {\n        if (text[0] === trigger) {\n          startIndex = 0;\n          counter = 0;\n          text = text.substr(trigger.length);\n        } else {\n          startIndex = text.indexOf(separator + trigger);\n          if (startIndex >= 0) {\n            text = text.substr(startIndex + (separator + trigger).length);\n            counter += startIndex + separator.length;\n          }\n        }\n        if (startIndex >= 0) {\n          var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;\n          var hashtag = text.substr(0, endIndex);\n          if (hashtag && hashtag.length > 0) {\n            sections.push({\n              offset: counter,\n              length: hashtag.length + trigger.length,\n              type: 'HASHTAG'\n            });\n          }\n          counter += trigger.length;\n        }\n      }\n    }\n    return sections;\n  }\n\n  /**\n  * The function returns an array of entity-sections in blocks.\n  * These will be areas in block which have same entity or no entity applicable to them.\n  */\n  function getSections(block, hashtagConfig) {\n    var sections = [];\n    var lastOffset = 0;\n    var sectionRanges = block.entityRanges.map(function (range) {\n      var offset = range.offset,\n        length = range.length,\n        key = range.key;\n      return {\n        offset: offset,\n        length: length,\n        key: key,\n        type: 'ENTITY'\n      };\n    });\n    sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n    sectionRanges = sectionRanges.sort(function (s1, s2) {\n      return s1.offset - s2.offset;\n    });\n    sectionRanges.forEach(function (r) {\n      if (r.offset > lastOffset) {\n        sections.push({\n          start: lastOffset,\n          end: r.offset\n        });\n      }\n      sections.push({\n        start: r.offset,\n        end: r.offset + r.length,\n        entityKey: r.key,\n        type: r.type\n      });\n      lastOffset = r.offset + r.length;\n    });\n    if (lastOffset < block.text.length) {\n      sections.push({\n        start: lastOffset,\n        end: block.text.length\n      });\n    }\n    return sections;\n  }\n\n  /**\n  * Function to check if the block is an atomic entity block.\n  */\n  function isAtomicEntityBlock(block) {\n    if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === 'atomic')) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n  * The function will return array of inline styles applicable to the block.\n  */\n  function getStyleArrayForBlock(block) {\n    var text = block.text,\n      inlineStyleRanges = block.inlineStyleRanges;\n    var inlineStyles = {\n      BOLD: new Array(text.length),\n      ITALIC: new Array(text.length),\n      UNDERLINE: new Array(text.length),\n      STRIKETHROUGH: new Array(text.length),\n      CODE: new Array(text.length),\n      SUPERSCRIPT: new Array(text.length),\n      SUBSCRIPT: new Array(text.length),\n      COLOR: new Array(text.length),\n      BGCOLOR: new Array(text.length),\n      FONTSIZE: new Array(text.length),\n      FONTFAMILY: new Array(text.length),\n      length: text.length\n    };\n    if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n      inlineStyleRanges.forEach(function (range) {\n        var offset = range.offset;\n        var length = offset + range.length;\n        for (var i = offset; i < length; i += 1) {\n          if (range.style.indexOf('color-') === 0) {\n            inlineStyles.COLOR[i] = range.style.substring(6);\n          } else if (range.style.indexOf('bgcolor-') === 0) {\n            inlineStyles.BGCOLOR[i] = range.style.substring(8);\n          } else if (range.style.indexOf('fontsize-') === 0) {\n            inlineStyles.FONTSIZE[i] = range.style.substring(9);\n          } else if (range.style.indexOf('fontfamily-') === 0) {\n            inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n          } else if (inlineStyles[range.style]) {\n            inlineStyles[range.style][i] = true;\n          }\n        }\n      });\n    }\n    return inlineStyles;\n  }\n\n  /**\n  * The function will return inline style applicable at some offset within a block.\n  */\n  function getStylesAtOffset(inlineStyles, offset) {\n    var styles = {};\n    if (inlineStyles.COLOR[offset]) {\n      styles.COLOR = inlineStyles.COLOR[offset];\n    }\n    if (inlineStyles.BGCOLOR[offset]) {\n      styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n    }\n    if (inlineStyles.FONTSIZE[offset]) {\n      styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n    }\n    if (inlineStyles.FONTFAMILY[offset]) {\n      styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n    }\n    if (inlineStyles.UNDERLINE[offset]) {\n      styles.UNDERLINE = true;\n    }\n    if (inlineStyles.ITALIC[offset]) {\n      styles.ITALIC = true;\n    }\n    if (inlineStyles.BOLD[offset]) {\n      styles.BOLD = true;\n    }\n    if (inlineStyles.STRIKETHROUGH[offset]) {\n      styles.STRIKETHROUGH = true;\n    }\n    if (inlineStyles.CODE[offset]) {\n      styles.CODE = true;\n    }\n    if (inlineStyles.SUBSCRIPT[offset]) {\n      styles.SUBSCRIPT = true;\n    }\n    if (inlineStyles.SUPERSCRIPT[offset]) {\n      styles.SUPERSCRIPT = true;\n    }\n    return styles;\n  }\n\n  /**\n  * Function returns true for a set of styles if the value of these styles at an offset\n  * are same as that on the previous offset.\n  */\n  function sameStyleAsPrevious(inlineStyles, styles, index) {\n    var sameStyled = true;\n    if (index > 0 && index < inlineStyles.length) {\n      styles.forEach(function (style) {\n        sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n      });\n    } else {\n      sameStyled = false;\n    }\n    return sameStyled;\n  }\n\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n  function addInlineStyleMarkup(style, content) {\n    if (style === 'BOLD') {\n      return '<strong>' + content + '</strong>';\n    } else if (style === 'ITALIC') {\n      return '<em>' + content + '</em>';\n    } else if (style === 'UNDERLINE') {\n      return '<ins>' + content + '</ins>';\n    } else if (style === 'STRIKETHROUGH') {\n      return '<del>' + content + '</del>';\n    } else if (style === 'CODE') {\n      return '<code>' + content + '</code>';\n    } else if (style === 'SUPERSCRIPT') {\n      return '<sup>' + content + '</sup>';\n    } else if (style === 'SUBSCRIPT') {\n      return '<sub>' + content + '</sub>';\n    }\n    return content;\n  }\n\n  /**\n  * The function returns text for given section of block after doing required character replacements.\n  */\n  function getSectionText(text) {\n    if (text && text.length > 0) {\n      var chars = text.map(function (ch) {\n        switch (ch) {\n          case '\\n':\n            return '<br>';\n          case '&':\n            return '&amp;';\n          case '<':\n            return '&lt;';\n          case '>':\n            return '&gt;';\n          default:\n            return ch;\n        }\n      });\n      return chars.join('');\n    }\n    return '';\n  }\n\n  /**\n  * Function returns html for text depending on inline style tags applicable to it.\n  */\n  function addStylePropertyMarkup(styles, text) {\n    if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n      var styleString = 'style=\"';\n      if (styles.COLOR) {\n        styleString += 'color: ' + styles.COLOR + ';';\n      }\n      if (styles.BGCOLOR) {\n        styleString += 'background-color: ' + styles.BGCOLOR + ';';\n      }\n      if (styles.FONTSIZE) {\n        styleString += 'font-size: ' + styles.FONTSIZE + (/^\\d+$/.test(styles.FONTSIZE) ? 'px' : '') + ';';\n      }\n      if (styles.FONTFAMILY) {\n        styleString += 'font-family: ' + styles.FONTFAMILY + ';';\n      }\n      styleString += '\"';\n      return '<span ' + styleString + '>' + text + '</span>';\n    }\n    return text;\n  }\n\n  /**\n  * Function will return markup for Entity.\n  */\n  function getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {\n    var entity = entityMap[entityKey];\n    if (typeof customEntityTransform === 'function') {\n      var html = customEntityTransform(entity, text);\n      if (html) {\n        return html;\n      }\n    }\n    if (entity.type === 'MENTION') {\n      return '<a href=\"' + entity.data.url + '\" class=\"wysiwyg-mention\" data-mention data-value=\"' + entity.data.value + '\">' + text + '</a>';\n    }\n    if (entity.type === 'LINK') {\n      var targetOption = entity.data.targetOption || '_self';\n      return '<a href=\"' + entity.data.url + '\" target=\"' + targetOption + '\">' + text + '</a>';\n    }\n    if (entity.type === 'IMAGE') {\n      return '<img src=\"' + entity.data.src + '\" alt=\"' + entity.data.alt + '\" style=\"float:' + (entity.data.alignment || 'none') + ';height: ' + entity.data.height + ';width: ' + entity.data.width + '\"/>';\n    }\n    if (entity.type === 'EMBEDDED_LINK') {\n      return '<iframe width=\"' + entity.data.width + '\" height=\"' + entity.data.height + '\" src=\"' + entity.data.src + '\" frameBorder=\"0\"></iframe>';\n    }\n    return text;\n  }\n\n  /**\n  * For a given section in a block the function will return a further list of sections,\n  * with similar inline styles applicable to them.\n  */\n  function getInlineStyleSections(block, styles, start, end) {\n    var styleSections = [];\n    var text = block.text;\n    if (text.length > 0) {\n      var inlineStyles = getStyleArrayForBlock(block);\n      var section = void 0;\n      for (var i = start; i < end; i += 1) {\n        if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n          section.text.push(text[i]);\n          section.end = i + 1;\n        } else {\n          section = {\n            styles: getStylesAtOffset(inlineStyles, i),\n            text: [text[i]],\n            start: i,\n            end: i + 1\n          };\n          styleSections.push(section);\n        }\n      }\n    }\n    return styleSections;\n  }\n\n  /**\n  * Replace leading blank spaces by &nbsp;\n  */\n  function trimLeadingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n      for (var i = 0; i < replacedText.length; i += 1) {\n        if (sectionText[i] === ' ') {\n          replacedText = replacedText.replace(' ', '&nbsp;');\n        } else {\n          break;\n        }\n      }\n      return replacedText;\n    }\n    return sectionText;\n  }\n\n  /**\n  * Replace trailing blank spaces by &nbsp;\n  */\n  function trimTrailingZeros(sectionText) {\n    if (sectionText) {\n      var replacedText = sectionText;\n      for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n        if (replacedText[i] === ' ') {\n          replacedText = replacedText.substring(0, i) + '&nbsp;' + replacedText.substring(i + 1);\n        } else {\n          break;\n        }\n      }\n      return replacedText;\n    }\n    return sectionText;\n  }\n\n  /**\n  * The method returns markup for section to which inline styles\n  * like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n  */\n  function getStyleTagSectionMarkup(styleSection) {\n    var styles = styleSection.styles,\n      text = styleSection.text;\n    var content = getSectionText(text);\n    forEach(styles, function (style, value) {\n      content = addInlineStyleMarkup(style, content, value);\n    });\n    return content;\n  }\n\n  /**\n  * The method returns markup for section to which inline styles\n  like color, background-color, font-size are applicable.\n  */\n  function getInlineStyleSectionMarkup(block, styleSection) {\n    var styleTagSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], styleSection.start, styleSection.end);\n    var styleSectionText = '';\n    styleTagSections.forEach(function (stylePropertySection) {\n      styleSectionText += getStyleTagSectionMarkup(stylePropertySection);\n    });\n    styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);\n    return styleSectionText;\n  }\n\n  /*\n  * The method returns markup for an entity section.\n  * An entity section is a continuous section in a block\n  * to which same entity or no entity is applicable.\n  */\n  function getSectionMarkup(block, entityMap, section, customEntityTransform) {\n    var entityInlineMarkup = [];\n    var inlineStyleSections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], section.start, section.end);\n    inlineStyleSections.forEach(function (styleSection) {\n      entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n    });\n    var sectionText = entityInlineMarkup.join('');\n    if (section.type === 'ENTITY') {\n      if (section.entityKey !== undefined && section.entityKey !== null) {\n        sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform); // eslint-disable-line max-len\n      }\n    } else if (section.type === 'HASHTAG') {\n      sectionText = '<a href=\"' + sectionText + '\" class=\"wysiwyg-hashtag\">' + sectionText + '</a>';\n    }\n    return sectionText;\n  }\n\n  /**\n  * Function will return the markup for block preserving the inline styles and\n  * special characters like newlines or blank spaces.\n  */\n  function getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {\n    var blockMarkup = [];\n    var sections = getSections(block, hashtagConfig);\n    sections.forEach(function (section, index) {\n      var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);\n      if (index === 0) {\n        sectionText = trimLeadingZeros(sectionText);\n      }\n      if (index === sections.length - 1) {\n        sectionText = trimTrailingZeros(sectionText);\n      }\n      blockMarkup.push(sectionText);\n    });\n    return blockMarkup.join('');\n  }\n\n  /**\n  * Function will return html for the block.\n  */\n  function getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var blockHtml = [];\n    if (isAtomicEntityBlock(block)) {\n      blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));\n    } else {\n      var blockTag = getBlockTag(block.type);\n      if (blockTag) {\n        blockHtml.push('<' + blockTag);\n        var blockStyle = getBlockStyle(block.data);\n        if (blockStyle) {\n          blockHtml.push(' style=\"' + blockStyle + '\"');\n        }\n        if (directional) {\n          blockHtml.push(' dir = \"auto\"');\n        }\n        blockHtml.push('>');\n        blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        blockHtml.push('</' + blockTag + '>');\n      }\n    }\n    blockHtml.push('\\n');\n    return blockHtml.join('');\n  }\n\n  /**\n  * Function to check if a block is of type list.\n  */\n  function isList(blockType) {\n    return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n  }\n\n  /**\n  * Function will return html markup for a list block.\n  */\n  function getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {\n    var listHtml = [];\n    var nestedListBlock = [];\n    var previousBlock = void 0;\n    listBlocks.forEach(function (block) {\n      var nestedBlock = false;\n      if (!previousBlock) {\n        listHtml.push('<' + getBlockTag(block.type) + '>\\n');\n      } else if (previousBlock.type !== block.type) {\n        listHtml.push('</' + getBlockTag(previousBlock.type) + '>\\n');\n        listHtml.push('<' + getBlockTag(block.type) + '>\\n');\n      } else if (previousBlock.depth === block.depth) {\n        if (nestedListBlock && nestedListBlock.length > 0) {\n          listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n          nestedListBlock = [];\n        }\n      } else {\n        nestedBlock = true;\n        nestedListBlock.push(block);\n      }\n      if (!nestedBlock) {\n        listHtml.push('<li');\n        var blockStyle = getBlockStyle(block.data);\n        if (blockStyle) {\n          listHtml.push(' style=\"' + blockStyle + '\"');\n        }\n        if (directional) {\n          listHtml.push(' dir = \"auto\"');\n        }\n        listHtml.push('>');\n        listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n        listHtml.push('</li>\\n');\n        previousBlock = block;\n      }\n    });\n    if (nestedListBlock && nestedListBlock.length > 0) {\n      listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n    }\n    listHtml.push('</' + getBlockTag(previousBlock.type) + '>\\n');\n    return listHtml.join('');\n  }\n\n  /**\n  * The function will generate html markup for given draftjs editorContent.\n  */\n  function draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {\n    var html = [];\n    if (editorContent) {\n      var blocks = editorContent.blocks,\n        entityMap = editorContent.entityMap;\n      if (blocks && blocks.length > 0) {\n        var listBlocks = [];\n        blocks.forEach(function (block) {\n          if (isList(block.type)) {\n            listBlocks.push(block);\n          } else {\n            if (listBlocks.length > 0) {\n              var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform); // eslint-disable-line max-len\n              html.push(listHtml);\n              listBlocks = [];\n            }\n            var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);\n            html.push(blockHtml);\n          }\n        });\n        if (listBlocks.length > 0) {\n          var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform); // eslint-disable-line max-len\n          html.push(listHtml);\n          listBlocks = [];\n        }\n      }\n    }\n    return html.join('');\n  }\n  return draftToHtml;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","draftjsToHtml","forEach","obj","callback","key","hasOwnProperty","call","isEmptyString","str","undefined","length","trim","blockTypesMapping","unstyled","blockquote","code","getBlockTag","type","getBlockStyle","data","styles","value","getHashtagRanges","blockText","hashtagConfig","sections","counter","startIndex","text","trigger","separator","substr","indexOf","endIndex","hashtag","push","offset","getSections","block","lastOffset","sectionRanges","entityRanges","map","range","concat","sort","s1","s2","r","start","end","entityKey","isAtomicEntityBlock","getStyleArrayForBlock","inlineStyleRanges","inlineStyles","BOLD","Array","ITALIC","UNDERLINE","STRIKETHROUGH","CODE","SUPERSCRIPT","SUBSCRIPT","COLOR","BGCOLOR","FONTSIZE","FONTFAMILY","i","style","substring","getStylesAtOffset","sameStyleAsPrevious","index","sameStyled","addInlineStyleMarkup","content","getSectionText","chars","ch","join","addStylePropertyMarkup","styleString","test","getEntityMarkup","entityMap","customEntityTransform","entity","html","url","targetOption","src","alt","alignment","height","width","getInlineStyleSections","styleSections","section","trimLeadingZeros","sectionText","replacedText","replace","trimTrailingZeros","getStyleTagSectionMarkup","styleSection","getInlineStyleSectionMarkup","styleTagSections","styleSectionText","stylePropertySection","getSectionMarkup","entityInlineMarkup","inlineStyleSections","getBlockInnerMarkup","blockMarkup","getBlockMarkup","directional","blockHtml","blockTag","blockStyle","isList","blockType","getListMarkup","listBlocks","listHtml","nestedListBlock","previousBlock","nestedBlock","depth","draftToHtml","editorContent","blocks"],"sources":["D:/task/node_modules/draftjs-to-html/lib/draftjs-to-html.js"],"sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.draftjsToHtml = factory());\n}(this, (function () { 'use strict';\n\n/**\n* Utility function to execute callback for eack key->value pair.\n*/\nfunction forEach(obj, callback) {\n  if (obj) {\n    for (var key in obj) {\n      // eslint-disable-line no-restricted-syntax\n      if ({}.hasOwnProperty.call(obj, key)) {\n        callback(key, obj[key]);\n      }\n    }\n  }\n}\n\n/**\n* The function returns true if the string passed to it has no content.\n*/\nfunction isEmptyString(str) {\n  if (str === undefined || str === null || str.length === 0 || str.trim().length === 0) {\n    return true;\n  }\n  return false;\n}\n\n/**\n* Mapping block-type to corresponding html tag.\n*/\nvar blockTypesMapping = {\n  unstyled: 'p',\n  'header-one': 'h1',\n  'header-two': 'h2',\n  'header-three': 'h3',\n  'header-four': 'h4',\n  'header-five': 'h5',\n  'header-six': 'h6',\n  'unordered-list-item': 'ul',\n  'ordered-list-item': 'ol',\n  blockquote: 'blockquote',\n  code: 'pre'\n};\n\n/**\n* Function will return HTML tag for a block.\n*/\nfunction getBlockTag(type) {\n  return type && blockTypesMapping[type];\n}\n\n/**\n* Function will return style string for a block.\n*/\nfunction getBlockStyle(data) {\n  var styles = '';\n  forEach(data, function (key, value) {\n    if (value) {\n      styles += key + ':' + value + ';';\n    }\n  });\n  return styles;\n}\n\n/**\n* The function returns an array of hashtag-sections in blocks.\n* These will be areas in block which have hashtags applicable to them.\n*/\nfunction getHashtagRanges(blockText, hashtagConfig) {\n  var sections = [];\n  if (hashtagConfig) {\n    var counter = 0;\n    var startIndex = 0;\n    var text = blockText;\n    var trigger = hashtagConfig.trigger || '#';\n    var separator = hashtagConfig.separator || ' ';\n    for (; text.length > 0 && startIndex >= 0;) {\n      if (text[0] === trigger) {\n        startIndex = 0;\n        counter = 0;\n        text = text.substr(trigger.length);\n      } else {\n        startIndex = text.indexOf(separator + trigger);\n        if (startIndex >= 0) {\n          text = text.substr(startIndex + (separator + trigger).length);\n          counter += startIndex + separator.length;\n        }\n      }\n      if (startIndex >= 0) {\n        var endIndex = text.indexOf(separator) >= 0 ? text.indexOf(separator) : text.length;\n        var hashtag = text.substr(0, endIndex);\n        if (hashtag && hashtag.length > 0) {\n          sections.push({\n            offset: counter,\n            length: hashtag.length + trigger.length,\n            type: 'HASHTAG'\n          });\n        }\n        counter += trigger.length;\n      }\n    }\n  }\n  return sections;\n}\n\n/**\n* The function returns an array of entity-sections in blocks.\n* These will be areas in block which have same entity or no entity applicable to them.\n*/\nfunction getSections(block, hashtagConfig) {\n  var sections = [];\n  var lastOffset = 0;\n  var sectionRanges = block.entityRanges.map(function (range) {\n    var offset = range.offset,\n        length = range.length,\n        key = range.key;\n\n    return {\n      offset: offset,\n      length: length,\n      key: key,\n      type: 'ENTITY'\n    };\n  });\n  sectionRanges = sectionRanges.concat(getHashtagRanges(block.text, hashtagConfig));\n  sectionRanges = sectionRanges.sort(function (s1, s2) {\n    return s1.offset - s2.offset;\n  });\n  sectionRanges.forEach(function (r) {\n    if (r.offset > lastOffset) {\n      sections.push({\n        start: lastOffset,\n        end: r.offset\n      });\n    }\n    sections.push({\n      start: r.offset,\n      end: r.offset + r.length,\n      entityKey: r.key,\n      type: r.type\n    });\n    lastOffset = r.offset + r.length;\n  });\n  if (lastOffset < block.text.length) {\n    sections.push({\n      start: lastOffset,\n      end: block.text.length\n    });\n  }\n  return sections;\n}\n\n/**\n* Function to check if the block is an atomic entity block.\n*/\nfunction isAtomicEntityBlock(block) {\n  if (block.entityRanges.length > 0 && (isEmptyString(block.text) || block.type === 'atomic')) {\n    return true;\n  }\n  return false;\n}\n\n/**\n* The function will return array of inline styles applicable to the block.\n*/\nfunction getStyleArrayForBlock(block) {\n  var text = block.text,\n      inlineStyleRanges = block.inlineStyleRanges;\n\n  var inlineStyles = {\n    BOLD: new Array(text.length),\n    ITALIC: new Array(text.length),\n    UNDERLINE: new Array(text.length),\n    STRIKETHROUGH: new Array(text.length),\n    CODE: new Array(text.length),\n    SUPERSCRIPT: new Array(text.length),\n    SUBSCRIPT: new Array(text.length),\n    COLOR: new Array(text.length),\n    BGCOLOR: new Array(text.length),\n    FONTSIZE: new Array(text.length),\n    FONTFAMILY: new Array(text.length),\n    length: text.length\n  };\n  if (inlineStyleRanges && inlineStyleRanges.length > 0) {\n    inlineStyleRanges.forEach(function (range) {\n      var offset = range.offset;\n\n      var length = offset + range.length;\n      for (var i = offset; i < length; i += 1) {\n        if (range.style.indexOf('color-') === 0) {\n          inlineStyles.COLOR[i] = range.style.substring(6);\n        } else if (range.style.indexOf('bgcolor-') === 0) {\n          inlineStyles.BGCOLOR[i] = range.style.substring(8);\n        } else if (range.style.indexOf('fontsize-') === 0) {\n          inlineStyles.FONTSIZE[i] = range.style.substring(9);\n        } else if (range.style.indexOf('fontfamily-') === 0) {\n          inlineStyles.FONTFAMILY[i] = range.style.substring(11);\n        } else if (inlineStyles[range.style]) {\n          inlineStyles[range.style][i] = true;\n        }\n      }\n    });\n  }\n  return inlineStyles;\n}\n\n/**\n* The function will return inline style applicable at some offset within a block.\n*/\nfunction getStylesAtOffset(inlineStyles, offset) {\n  var styles = {};\n  if (inlineStyles.COLOR[offset]) {\n    styles.COLOR = inlineStyles.COLOR[offset];\n  }\n  if (inlineStyles.BGCOLOR[offset]) {\n    styles.BGCOLOR = inlineStyles.BGCOLOR[offset];\n  }\n  if (inlineStyles.FONTSIZE[offset]) {\n    styles.FONTSIZE = inlineStyles.FONTSIZE[offset];\n  }\n  if (inlineStyles.FONTFAMILY[offset]) {\n    styles.FONTFAMILY = inlineStyles.FONTFAMILY[offset];\n  }\n  if (inlineStyles.UNDERLINE[offset]) {\n    styles.UNDERLINE = true;\n  }\n  if (inlineStyles.ITALIC[offset]) {\n    styles.ITALIC = true;\n  }\n  if (inlineStyles.BOLD[offset]) {\n    styles.BOLD = true;\n  }\n  if (inlineStyles.STRIKETHROUGH[offset]) {\n    styles.STRIKETHROUGH = true;\n  }\n  if (inlineStyles.CODE[offset]) {\n    styles.CODE = true;\n  }\n  if (inlineStyles.SUBSCRIPT[offset]) {\n    styles.SUBSCRIPT = true;\n  }\n  if (inlineStyles.SUPERSCRIPT[offset]) {\n    styles.SUPERSCRIPT = true;\n  }\n  return styles;\n}\n\n/**\n* Function returns true for a set of styles if the value of these styles at an offset\n* are same as that on the previous offset.\n*/\nfunction sameStyleAsPrevious(inlineStyles, styles, index) {\n  var sameStyled = true;\n  if (index > 0 && index < inlineStyles.length) {\n    styles.forEach(function (style) {\n      sameStyled = sameStyled && inlineStyles[style][index] === inlineStyles[style][index - 1];\n    });\n  } else {\n    sameStyled = false;\n  }\n  return sameStyled;\n}\n\n/**\n* Function returns html for text depending on inline style tags applicable to it.\n*/\nfunction addInlineStyleMarkup(style, content) {\n  if (style === 'BOLD') {\n    return '<strong>' + content + '</strong>';\n  } else if (style === 'ITALIC') {\n    return '<em>' + content + '</em>';\n  } else if (style === 'UNDERLINE') {\n    return '<ins>' + content + '</ins>';\n  } else if (style === 'STRIKETHROUGH') {\n    return '<del>' + content + '</del>';\n  } else if (style === 'CODE') {\n    return '<code>' + content + '</code>';\n  } else if (style === 'SUPERSCRIPT') {\n    return '<sup>' + content + '</sup>';\n  } else if (style === 'SUBSCRIPT') {\n    return '<sub>' + content + '</sub>';\n  }\n  return content;\n}\n\n/**\n* The function returns text for given section of block after doing required character replacements.\n*/\nfunction getSectionText(text) {\n  if (text && text.length > 0) {\n    var chars = text.map(function (ch) {\n      switch (ch) {\n        case '\\n':\n          return '<br>';\n        case '&':\n          return '&amp;';\n        case '<':\n          return '&lt;';\n        case '>':\n          return '&gt;';\n        default:\n          return ch;\n      }\n    });\n    return chars.join('');\n  }\n  return '';\n}\n\n/**\n* Function returns html for text depending on inline style tags applicable to it.\n*/\nfunction addStylePropertyMarkup(styles, text) {\n  if (styles && (styles.COLOR || styles.BGCOLOR || styles.FONTSIZE || styles.FONTFAMILY)) {\n    var styleString = 'style=\"';\n    if (styles.COLOR) {\n      styleString += 'color: ' + styles.COLOR + ';';\n    }\n    if (styles.BGCOLOR) {\n      styleString += 'background-color: ' + styles.BGCOLOR + ';';\n    }\n    if (styles.FONTSIZE) {\n      styleString += 'font-size: ' + styles.FONTSIZE + (/^\\d+$/.test(styles.FONTSIZE) ? 'px' : '') + ';';\n    }\n    if (styles.FONTFAMILY) {\n      styleString += 'font-family: ' + styles.FONTFAMILY + ';';\n    }\n    styleString += '\"';\n    return '<span ' + styleString + '>' + text + '</span>';\n  }\n  return text;\n}\n\n/**\n* Function will return markup for Entity.\n*/\nfunction getEntityMarkup(entityMap, entityKey, text, customEntityTransform) {\n  var entity = entityMap[entityKey];\n  if (typeof customEntityTransform === 'function') {\n    var html = customEntityTransform(entity, text);\n    if (html) {\n      return html;\n    }\n  }\n  if (entity.type === 'MENTION') {\n    return '<a href=\"' + entity.data.url + '\" class=\"wysiwyg-mention\" data-mention data-value=\"' + entity.data.value + '\">' + text + '</a>';\n  }\n  if (entity.type === 'LINK') {\n    var targetOption = entity.data.targetOption || '_self';\n    return '<a href=\"' + entity.data.url + '\" target=\"' + targetOption + '\">' + text + '</a>';\n  }\n  if (entity.type === 'IMAGE') {\n    return '<img src=\"' + entity.data.src + '\" alt=\"' + entity.data.alt + '\" style=\"float:' + (entity.data.alignment || 'none') + ';height: ' + entity.data.height + ';width: ' + entity.data.width + '\"/>';\n  }\n  if (entity.type === 'EMBEDDED_LINK') {\n    return '<iframe width=\"' + entity.data.width + '\" height=\"' + entity.data.height + '\" src=\"' + entity.data.src + '\" frameBorder=\"0\"></iframe>';\n  }\n  return text;\n}\n\n/**\n* For a given section in a block the function will return a further list of sections,\n* with similar inline styles applicable to them.\n*/\nfunction getInlineStyleSections(block, styles, start, end) {\n  var styleSections = [];\n  var text = block.text;\n\n  if (text.length > 0) {\n    var inlineStyles = getStyleArrayForBlock(block);\n    var section = void 0;\n    for (var i = start; i < end; i += 1) {\n      if (i !== start && sameStyleAsPrevious(inlineStyles, styles, i)) {\n        section.text.push(text[i]);\n        section.end = i + 1;\n      } else {\n        section = {\n          styles: getStylesAtOffset(inlineStyles, i),\n          text: [text[i]],\n          start: i,\n          end: i + 1\n        };\n        styleSections.push(section);\n      }\n    }\n  }\n  return styleSections;\n}\n\n/**\n* Replace leading blank spaces by &nbsp;\n*/\nfunction trimLeadingZeros(sectionText) {\n  if (sectionText) {\n    var replacedText = sectionText;\n    for (var i = 0; i < replacedText.length; i += 1) {\n      if (sectionText[i] === ' ') {\n        replacedText = replacedText.replace(' ', '&nbsp;');\n      } else {\n        break;\n      }\n    }\n    return replacedText;\n  }\n  return sectionText;\n}\n\n/**\n* Replace trailing blank spaces by &nbsp;\n*/\nfunction trimTrailingZeros(sectionText) {\n  if (sectionText) {\n    var replacedText = sectionText;\n    for (var i = replacedText.length - 1; i >= 0; i -= 1) {\n      if (replacedText[i] === ' ') {\n        replacedText = replacedText.substring(0, i) + '&nbsp;' + replacedText.substring(i + 1);\n      } else {\n        break;\n      }\n    }\n    return replacedText;\n  }\n  return sectionText;\n}\n\n/**\n* The method returns markup for section to which inline styles\n* like BOLD, ITALIC, UNDERLINE, STRIKETHROUGH, CODE, SUPERSCRIPT, SUBSCRIPT are applicable.\n*/\nfunction getStyleTagSectionMarkup(styleSection) {\n  var styles = styleSection.styles,\n      text = styleSection.text;\n\n  var content = getSectionText(text);\n  forEach(styles, function (style, value) {\n    content = addInlineStyleMarkup(style, content, value);\n  });\n  return content;\n}\n\n/**\n* The method returns markup for section to which inline styles\nlike color, background-color, font-size are applicable.\n*/\nfunction getInlineStyleSectionMarkup(block, styleSection) {\n  var styleTagSections = getInlineStyleSections(block, ['BOLD', 'ITALIC', 'UNDERLINE', 'STRIKETHROUGH', 'CODE', 'SUPERSCRIPT', 'SUBSCRIPT'], styleSection.start, styleSection.end);\n  var styleSectionText = '';\n  styleTagSections.forEach(function (stylePropertySection) {\n    styleSectionText += getStyleTagSectionMarkup(stylePropertySection);\n  });\n  styleSectionText = addStylePropertyMarkup(styleSection.styles, styleSectionText);\n  return styleSectionText;\n}\n\n/*\n* The method returns markup for an entity section.\n* An entity section is a continuous section in a block\n* to which same entity or no entity is applicable.\n*/\nfunction getSectionMarkup(block, entityMap, section, customEntityTransform) {\n  var entityInlineMarkup = [];\n  var inlineStyleSections = getInlineStyleSections(block, ['COLOR', 'BGCOLOR', 'FONTSIZE', 'FONTFAMILY'], section.start, section.end);\n  inlineStyleSections.forEach(function (styleSection) {\n    entityInlineMarkup.push(getInlineStyleSectionMarkup(block, styleSection));\n  });\n  var sectionText = entityInlineMarkup.join('');\n  if (section.type === 'ENTITY') {\n    if (section.entityKey !== undefined && section.entityKey !== null) {\n      sectionText = getEntityMarkup(entityMap, section.entityKey, sectionText, customEntityTransform); // eslint-disable-line max-len\n    }\n  } else if (section.type === 'HASHTAG') {\n    sectionText = '<a href=\"' + sectionText + '\" class=\"wysiwyg-hashtag\">' + sectionText + '</a>';\n  }\n  return sectionText;\n}\n\n/**\n* Function will return the markup for block preserving the inline styles and\n* special characters like newlines or blank spaces.\n*/\nfunction getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform) {\n  var blockMarkup = [];\n  var sections = getSections(block, hashtagConfig);\n  sections.forEach(function (section, index) {\n    var sectionText = getSectionMarkup(block, entityMap, section, customEntityTransform);\n    if (index === 0) {\n      sectionText = trimLeadingZeros(sectionText);\n    }\n    if (index === sections.length - 1) {\n      sectionText = trimTrailingZeros(sectionText);\n    }\n    blockMarkup.push(sectionText);\n  });\n  return blockMarkup.join('');\n}\n\n/**\n* Function will return html for the block.\n*/\nfunction getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform) {\n  var blockHtml = [];\n  if (isAtomicEntityBlock(block)) {\n    blockHtml.push(getEntityMarkup(entityMap, block.entityRanges[0].key, undefined, customEntityTransform));\n  } else {\n    var blockTag = getBlockTag(block.type);\n    if (blockTag) {\n      blockHtml.push('<' + blockTag);\n      var blockStyle = getBlockStyle(block.data);\n      if (blockStyle) {\n        blockHtml.push(' style=\"' + blockStyle + '\"');\n      }\n      if (directional) {\n        blockHtml.push(' dir = \"auto\"');\n      }\n      blockHtml.push('>');\n      blockHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n      blockHtml.push('</' + blockTag + '>');\n    }\n  }\n  blockHtml.push('\\n');\n  return blockHtml.join('');\n}\n\n/**\n* Function to check if a block is of type list.\n*/\nfunction isList(blockType) {\n  return blockType === 'unordered-list-item' || blockType === 'ordered-list-item';\n}\n\n/**\n* Function will return html markup for a list block.\n*/\nfunction getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform) {\n  var listHtml = [];\n  var nestedListBlock = [];\n  var previousBlock = void 0;\n  listBlocks.forEach(function (block) {\n    var nestedBlock = false;\n    if (!previousBlock) {\n      listHtml.push('<' + getBlockTag(block.type) + '>\\n');\n    } else if (previousBlock.type !== block.type) {\n      listHtml.push('</' + getBlockTag(previousBlock.type) + '>\\n');\n      listHtml.push('<' + getBlockTag(block.type) + '>\\n');\n    } else if (previousBlock.depth === block.depth) {\n      if (nestedListBlock && nestedListBlock.length > 0) {\n        listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n        nestedListBlock = [];\n      }\n    } else {\n      nestedBlock = true;\n      nestedListBlock.push(block);\n    }\n    if (!nestedBlock) {\n      listHtml.push('<li');\n      var blockStyle = getBlockStyle(block.data);\n      if (blockStyle) {\n        listHtml.push(' style=\"' + blockStyle + '\"');\n      }\n      if (directional) {\n        listHtml.push(' dir = \"auto\"');\n      }\n      listHtml.push('>');\n      listHtml.push(getBlockInnerMarkup(block, entityMap, hashtagConfig, customEntityTransform));\n      listHtml.push('</li>\\n');\n      previousBlock = block;\n    }\n  });\n  if (nestedListBlock && nestedListBlock.length > 0) {\n    listHtml.push(getListMarkup(nestedListBlock, entityMap, hashtagConfig, directional, customEntityTransform));\n  }\n  listHtml.push('</' + getBlockTag(previousBlock.type) + '>\\n');\n  return listHtml.join('');\n}\n\n/**\n* The function will generate html markup for given draftjs editorContent.\n*/\nfunction draftToHtml(editorContent, hashtagConfig, directional, customEntityTransform) {\n  var html = [];\n  if (editorContent) {\n    var blocks = editorContent.blocks,\n        entityMap = editorContent.entityMap;\n\n    if (blocks && blocks.length > 0) {\n      var listBlocks = [];\n      blocks.forEach(function (block) {\n        if (isList(block.type)) {\n          listBlocks.push(block);\n        } else {\n          if (listBlocks.length > 0) {\n            var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, customEntityTransform); // eslint-disable-line max-len\n            html.push(listHtml);\n            listBlocks = [];\n          }\n          var blockHtml = getBlockMarkup(block, entityMap, hashtagConfig, directional, customEntityTransform);\n          html.push(blockHtml);\n        }\n      });\n      if (listBlocks.length > 0) {\n        var listHtml = getListMarkup(listBlocks, entityMap, hashtagConfig, directional, customEntityTransform); // eslint-disable-line max-len\n        html.push(listHtml);\n        listBlocks = [];\n      }\n    }\n  }\n  return html.join('');\n}\n\nreturn draftToHtml;\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}