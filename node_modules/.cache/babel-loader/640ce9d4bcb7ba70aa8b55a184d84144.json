{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/task/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _inherits from \"D:/task/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/task/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"D:/task/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/task/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/*!\n * Signature Pad v4.1.4 | https://github.com/szimek/signature_pad\n * (c) 2022 Szymon Nowak | Released under the MIT license\n */\nvar Point = /*#__PURE__*/function () {\n  function Point(x, y, pressure, time) {\n    _classCallCheck(this, Point);\n    if (isNaN(x) || isNaN(y)) {\n      throw new Error(\"Point is invalid: (\".concat(x, \", \").concat(y, \")\"));\n    }\n    this.x = +x;\n    this.y = +y;\n    this.pressure = pressure || 0;\n    this.time = time || Date.now();\n  }\n  _createClass(Point, [{\n    key: \"distanceTo\",\n    value: function distanceTo(start) {\n      return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.x === other.x && this.y === other.y && this.pressure === other.pressure && this.time === other.time;\n    }\n  }, {\n    key: \"velocityFrom\",\n    value: function velocityFrom(start) {\n      return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 0;\n    }\n  }]);\n  return Point;\n}();\nvar Bezier = /*#__PURE__*/function () {\n  function Bezier(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n    _classCallCheck(this, Bezier);\n    this.startPoint = startPoint;\n    this.control2 = control2;\n    this.control1 = control1;\n    this.endPoint = endPoint;\n    this.startWidth = startWidth;\n    this.endWidth = endWidth;\n  }\n  _createClass(Bezier, [{\n    key: \"length\",\n    value: function length() {\n      var steps = 10;\n      var length = 0;\n      var px;\n      var py;\n      for (var i = 0; i <= steps; i += 1) {\n        var t = i / steps;\n        var cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n        var cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n        if (i > 0) {\n          var xdiff = cx - px;\n          var ydiff = cy - py;\n          length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n        }\n        px = cx;\n        py = cy;\n      }\n      return length;\n    }\n  }, {\n    key: \"point\",\n    value: function point(t, start, c1, c2, end) {\n      return start * (1.0 - t) * (1.0 - t) * (1.0 - t) + 3.0 * c1 * (1.0 - t) * (1.0 - t) * t + 3.0 * c2 * (1.0 - t) * t * t + end * t * t * t;\n    }\n  }], [{\n    key: \"fromPoints\",\n    value: function fromPoints(points, widths) {\n      var c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n      var c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n      return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n    }\n  }, {\n    key: \"calculateControlPoints\",\n    value: function calculateControlPoints(s1, s2, s3) {\n      var dx1 = s1.x - s2.x;\n      var dy1 = s1.y - s2.y;\n      var dx2 = s2.x - s3.x;\n      var dy2 = s2.y - s3.y;\n      var m1 = {\n        x: (s1.x + s2.x) / 2.0,\n        y: (s1.y + s2.y) / 2.0\n      };\n      var m2 = {\n        x: (s2.x + s3.x) / 2.0,\n        y: (s2.y + s3.y) / 2.0\n      };\n      var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n      var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n      var dxm = m1.x - m2.x;\n      var dym = m1.y - m2.y;\n      var k = l2 / (l1 + l2);\n      var cm = {\n        x: m2.x + dxm * k,\n        y: m2.y + dym * k\n      };\n      var tx = s2.x - cm.x;\n      var ty = s2.y - cm.y;\n      return {\n        c1: new Point(m1.x + tx, m1.y + ty),\n        c2: new Point(m2.x + tx, m2.y + ty)\n      };\n    }\n  }]);\n  return Bezier;\n}();\nvar SignatureEventTarget = /*#__PURE__*/function () {\n  function SignatureEventTarget() {\n    _classCallCheck(this, SignatureEventTarget);\n    try {\n      this._et = new EventTarget();\n    } catch (error) {\n      this._et = document;\n    }\n  }\n  _createClass(SignatureEventTarget, [{\n    key: \"addEventListener\",\n    value: function addEventListener(type, listener, options) {\n      this._et.addEventListener(type, listener, options);\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      return this._et.dispatchEvent(event);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(type, callback, options) {\n      this._et.removeEventListener(type, callback, options);\n    }\n  }]);\n  return SignatureEventTarget;\n}();\nfunction throttle(fn) {\n  var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;\n  var previous = 0;\n  var timeout = null;\n  var result;\n  var storedContext;\n  var storedArgs;\n  var later = function later() {\n    previous = Date.now();\n    timeout = null;\n    result = fn.apply(storedContext, storedArgs);\n    if (!timeout) {\n      storedContext = null;\n      storedArgs = [];\n    }\n  };\n  return function wrapper() {\n    var now = Date.now();\n    var remaining = wait - (now - previous);\n    storedContext = this;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    storedArgs = args;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = fn.apply(storedContext, storedArgs);\n      if (!timeout) {\n        storedContext = null;\n        storedArgs = [];\n      }\n    } else if (!timeout) {\n      timeout = window.setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\nvar SignaturePad = /*#__PURE__*/function (_SignatureEventTarget) {\n  _inherits(SignaturePad, _SignatureEventTarget);\n  var _super = _createSuper(SignaturePad);\n  function SignaturePad(canvas) {\n    var _this;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, SignaturePad);\n    _this = _super.call(this);\n    _this.canvas = canvas;\n    _this._handleMouseDown = function (event) {\n      if (event.buttons === 1) {\n        _this._drawningStroke = true;\n        _this._strokeBegin(event);\n      }\n    };\n    _this._handleMouseMove = function (event) {\n      if (_this._drawningStroke) {\n        _this._strokeMoveUpdate(event);\n      }\n    };\n    _this._handleMouseUp = function (event) {\n      if (event.buttons === 1 && _this._drawningStroke) {\n        _this._drawningStroke = false;\n        _this._strokeEnd(event);\n      }\n    };\n    _this._handleTouchStart = function (event) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      if (event.targetTouches.length === 1) {\n        var touch = event.changedTouches[0];\n        _this._strokeBegin(touch);\n      }\n    };\n    _this._handleTouchMove = function (event) {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n      var touch = event.targetTouches[0];\n      _this._strokeMoveUpdate(touch);\n    };\n    _this._handleTouchEnd = function (event) {\n      var wasCanvasTouched = event.target === _this.canvas;\n      if (wasCanvasTouched) {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n        var touch = event.changedTouches[0];\n        _this._strokeEnd(touch);\n      }\n    };\n    _this._handlePointerStart = function (event) {\n      _this._drawningStroke = true;\n      event.preventDefault();\n      _this._strokeBegin(event);\n    };\n    _this._handlePointerMove = function (event) {\n      if (_this._drawningStroke) {\n        event.preventDefault();\n        _this._strokeMoveUpdate(event);\n      }\n    };\n    _this._handlePointerEnd = function (event) {\n      if (_this._drawningStroke) {\n        event.preventDefault();\n        _this._drawningStroke = false;\n        _this._strokeEnd(event);\n      }\n    };\n    _this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n    _this.minWidth = options.minWidth || 0.5;\n    _this.maxWidth = options.maxWidth || 2.5;\n    _this.throttle = 'throttle' in options ? options.throttle : 16;\n    _this.minDistance = 'minDistance' in options ? options.minDistance : 5;\n    _this.dotSize = options.dotSize || 0;\n    _this.penColor = options.penColor || 'black';\n    _this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n    _this._strokeMoveUpdate = _this.throttle ? throttle(SignaturePad.prototype._strokeUpdate, _this.throttle) : SignaturePad.prototype._strokeUpdate;\n    _this._ctx = canvas.getContext('2d');\n    _this.clear();\n    _this.on();\n    return _this;\n  }\n  _createClass(SignaturePad, [{\n    key: \"clear\",\n    value: function clear() {\n      var ctx = this._ctx,\n        canvas = this.canvas;\n      ctx.fillStyle = this.backgroundColor;\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      this._data = [];\n      this._reset(this._getPointGroupOptions());\n      this._isEmpty = true;\n    }\n  }, {\n    key: \"fromDataURL\",\n    value: function fromDataURL(dataUrl) {\n      var _this2 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new Promise(function (resolve, reject) {\n        var image = new Image();\n        var ratio = options.ratio || window.devicePixelRatio || 1;\n        var width = options.width || _this2.canvas.width / ratio;\n        var height = options.height || _this2.canvas.height / ratio;\n        var xOffset = options.xOffset || 0;\n        var yOffset = options.yOffset || 0;\n        _this2._reset(_this2._getPointGroupOptions());\n        image.onload = function () {\n          _this2._ctx.drawImage(image, xOffset, yOffset, width, height);\n          resolve();\n        };\n        image.onerror = function (error) {\n          reject(error);\n        };\n        image.crossOrigin = 'anonymous';\n        image.src = dataUrl;\n        _this2._isEmpty = false;\n      });\n    }\n  }, {\n    key: \"toDataURL\",\n    value: function toDataURL() {\n      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'image/png';\n      var encoderOptions = arguments.length > 1 ? arguments[1] : undefined;\n      switch (type) {\n        case 'image/svg+xml':\n          if (typeof encoderOptions !== 'object') {\n            encoderOptions = undefined;\n          }\n          return \"data:image/svg+xml;base64,\".concat(btoa(this.toSVG(encoderOptions)));\n        default:\n          if (typeof encoderOptions !== 'number') {\n            encoderOptions = undefined;\n          }\n          return this.canvas.toDataURL(type, encoderOptions);\n      }\n    }\n  }, {\n    key: \"on\",\n    value: function on() {\n      this.canvas.style.touchAction = 'none';\n      this.canvas.style.msTouchAction = 'none';\n      this.canvas.style.userSelect = 'none';\n      var isIOS = /Macintosh/.test(navigator.userAgent) && 'ontouchstart' in document;\n      if (window.PointerEvent && !isIOS) {\n        this._handlePointerEvents();\n      } else {\n        this._handleMouseEvents();\n        if ('ontouchstart' in window) {\n          this._handleTouchEvents();\n        }\n      }\n    }\n  }, {\n    key: \"off\",\n    value: function off() {\n      this.canvas.style.touchAction = 'auto';\n      this.canvas.style.msTouchAction = 'auto';\n      this.canvas.style.userSelect = 'auto';\n      this.canvas.removeEventListener('pointerdown', this._handlePointerStart);\n      this.canvas.removeEventListener('pointermove', this._handlePointerMove);\n      this.canvas.ownerDocument.removeEventListener('pointerup', this._handlePointerEnd);\n      this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n      this.canvas.removeEventListener('mousemove', this._handleMouseMove);\n      this.canvas.ownerDocument.removeEventListener('mouseup', this._handleMouseUp);\n      this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n      this.canvas.removeEventListener('touchmove', this._handleTouchMove);\n      this.canvas.removeEventListener('touchend', this._handleTouchEnd);\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._isEmpty;\n    }\n  }, {\n    key: \"fromData\",\n    value: function fromData(pointGroups) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$clear = _ref.clear,\n        clear = _ref$clear === void 0 ? true : _ref$clear;\n      if (clear) {\n        this.clear();\n      }\n      this._fromData(pointGroups, this._drawCurve.bind(this), this._drawDot.bind(this));\n      this._data = this._data.concat(pointGroups);\n    }\n  }, {\n    key: \"toData\",\n    value: function toData() {\n      return this._data;\n    }\n  }, {\n    key: \"_getPointGroupOptions\",\n    value: function _getPointGroupOptions(group) {\n      return {\n        penColor: group && 'penColor' in group ? group.penColor : this.penColor,\n        dotSize: group && 'dotSize' in group ? group.dotSize : this.dotSize,\n        minWidth: group && 'minWidth' in group ? group.minWidth : this.minWidth,\n        maxWidth: group && 'maxWidth' in group ? group.maxWidth : this.maxWidth,\n        velocityFilterWeight: group && 'velocityFilterWeight' in group ? group.velocityFilterWeight : this.velocityFilterWeight\n      };\n    }\n  }, {\n    key: \"_strokeBegin\",\n    value: function _strokeBegin(event) {\n      this.dispatchEvent(new CustomEvent('beginStroke', {\n        detail: event\n      }));\n      var pointGroupOptions = this._getPointGroupOptions();\n      var newPointGroup = Object.assign(Object.assign({}, pointGroupOptions), {\n        points: []\n      });\n      this._data.push(newPointGroup);\n      this._reset(pointGroupOptions);\n      this._strokeUpdate(event);\n    }\n  }, {\n    key: \"_strokeUpdate\",\n    value: function _strokeUpdate(event) {\n      if (this._data.length === 0) {\n        this._strokeBegin(event);\n        return;\n      }\n      this.dispatchEvent(new CustomEvent('beforeUpdateStroke', {\n        detail: event\n      }));\n      var x = event.clientX;\n      var y = event.clientY;\n      var pressure = event.pressure !== undefined ? event.pressure : event.force !== undefined ? event.force : 0;\n      var point = this._createPoint(x, y, pressure);\n      var lastPointGroup = this._data[this._data.length - 1];\n      var lastPoints = lastPointGroup.points;\n      var lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n      var isLastPointTooClose = lastPoint ? point.distanceTo(lastPoint) <= this.minDistance : false;\n      var pointGroupOptions = this._getPointGroupOptions(lastPointGroup);\n      if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n        var curve = this._addPoint(point, pointGroupOptions);\n        if (!lastPoint) {\n          this._drawDot(point, pointGroupOptions);\n        } else if (curve) {\n          this._drawCurve(curve, pointGroupOptions);\n        }\n        lastPoints.push({\n          time: point.time,\n          x: point.x,\n          y: point.y,\n          pressure: point.pressure\n        });\n      }\n      this.dispatchEvent(new CustomEvent('afterUpdateStroke', {\n        detail: event\n      }));\n    }\n  }, {\n    key: \"_strokeEnd\",\n    value: function _strokeEnd(event) {\n      this._strokeUpdate(event);\n      this.dispatchEvent(new CustomEvent('endStroke', {\n        detail: event\n      }));\n    }\n  }, {\n    key: \"_handlePointerEvents\",\n    value: function _handlePointerEvents() {\n      this._drawningStroke = false;\n      this.canvas.addEventListener('pointerdown', this._handlePointerStart);\n      this.canvas.addEventListener('pointermove', this._handlePointerMove);\n      this.canvas.ownerDocument.addEventListener('pointerup', this._handlePointerEnd);\n    }\n  }, {\n    key: \"_handleMouseEvents\",\n    value: function _handleMouseEvents() {\n      this._drawningStroke = false;\n      this.canvas.addEventListener('mousedown', this._handleMouseDown);\n      this.canvas.addEventListener('mousemove', this._handleMouseMove);\n      this.canvas.ownerDocument.addEventListener('mouseup', this._handleMouseUp);\n    }\n  }, {\n    key: \"_handleTouchEvents\",\n    value: function _handleTouchEvents() {\n      this.canvas.addEventListener('touchstart', this._handleTouchStart);\n      this.canvas.addEventListener('touchmove', this._handleTouchMove);\n      this.canvas.addEventListener('touchend', this._handleTouchEnd);\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset(options) {\n      this._lastPoints = [];\n      this._lastVelocity = 0;\n      this._lastWidth = (options.minWidth + options.maxWidth) / 2;\n      this._ctx.fillStyle = options.penColor;\n    }\n  }, {\n    key: \"_createPoint\",\n    value: function _createPoint(x, y, pressure) {\n      var rect = this.canvas.getBoundingClientRect();\n      return new Point(x - rect.left, y - rect.top, pressure, new Date().getTime());\n    }\n  }, {\n    key: \"_addPoint\",\n    value: function _addPoint(point, options) {\n      var _lastPoints = this._lastPoints;\n      _lastPoints.push(point);\n      if (_lastPoints.length > 2) {\n        if (_lastPoints.length === 3) {\n          _lastPoints.unshift(_lastPoints[0]);\n        }\n        var widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2], options);\n        var curve = Bezier.fromPoints(_lastPoints, widths);\n        _lastPoints.shift();\n        return curve;\n      }\n      return null;\n    }\n  }, {\n    key: \"_calculateCurveWidths\",\n    value: function _calculateCurveWidths(startPoint, endPoint, options) {\n      var velocity = options.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - options.velocityFilterWeight) * this._lastVelocity;\n      var newWidth = this._strokeWidth(velocity, options);\n      var widths = {\n        end: newWidth,\n        start: this._lastWidth\n      };\n      this._lastVelocity = velocity;\n      this._lastWidth = newWidth;\n      return widths;\n    }\n  }, {\n    key: \"_strokeWidth\",\n    value: function _strokeWidth(velocity, options) {\n      return Math.max(options.maxWidth / (velocity + 1), options.minWidth);\n    }\n  }, {\n    key: \"_drawCurveSegment\",\n    value: function _drawCurveSegment(x, y, width) {\n      var ctx = this._ctx;\n      ctx.moveTo(x, y);\n      ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n      this._isEmpty = false;\n    }\n  }, {\n    key: \"_drawCurve\",\n    value: function _drawCurve(curve, options) {\n      var ctx = this._ctx;\n      var widthDelta = curve.endWidth - curve.startWidth;\n      var drawSteps = Math.ceil(curve.length()) * 2;\n      ctx.beginPath();\n      ctx.fillStyle = options.penColor;\n      for (var i = 0; i < drawSteps; i += 1) {\n        var t = i / drawSteps;\n        var tt = t * t;\n        var ttt = tt * t;\n        var u = 1 - t;\n        var uu = u * u;\n        var uuu = uu * u;\n        var x = uuu * curve.startPoint.x;\n        x += 3 * uu * t * curve.control1.x;\n        x += 3 * u * tt * curve.control2.x;\n        x += ttt * curve.endPoint.x;\n        var y = uuu * curve.startPoint.y;\n        y += 3 * uu * t * curve.control1.y;\n        y += 3 * u * tt * curve.control2.y;\n        y += ttt * curve.endPoint.y;\n        var width = Math.min(curve.startWidth + ttt * widthDelta, options.maxWidth);\n        this._drawCurveSegment(x, y, width);\n      }\n      ctx.closePath();\n      ctx.fill();\n    }\n  }, {\n    key: \"_drawDot\",\n    value: function _drawDot(point, options) {\n      var ctx = this._ctx;\n      var width = options.dotSize > 0 ? options.dotSize : (options.minWidth + options.maxWidth) / 2;\n      ctx.beginPath();\n      this._drawCurveSegment(point.x, point.y, width);\n      ctx.closePath();\n      ctx.fillStyle = options.penColor;\n      ctx.fill();\n    }\n  }, {\n    key: \"_fromData\",\n    value: function _fromData(pointGroups, drawCurve, drawDot) {\n      var _iterator = _createForOfIteratorHelper(pointGroups),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var group = _step.value;\n          var points = group.points;\n          var pointGroupOptions = this._getPointGroupOptions(group);\n          if (points.length > 1) {\n            for (var j = 0; j < points.length; j += 1) {\n              var basicPoint = points[j];\n              var point = new Point(basicPoint.x, basicPoint.y, basicPoint.pressure, basicPoint.time);\n              if (j === 0) {\n                this._reset(pointGroupOptions);\n              }\n              var curve = this._addPoint(point, pointGroupOptions);\n              if (curve) {\n                drawCurve(curve, pointGroupOptions);\n              }\n            }\n          } else {\n            this._reset(pointGroupOptions);\n            drawDot(points[0], pointGroupOptions);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"toSVG\",\n    value: function toSVG() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$includeBackgrou = _ref2.includeBackgroundColor,\n        includeBackgroundColor = _ref2$includeBackgrou === void 0 ? false : _ref2$includeBackgrou;\n      var pointGroups = this._data;\n      var ratio = Math.max(window.devicePixelRatio || 1, 1);\n      var minX = 0;\n      var minY = 0;\n      var maxX = this.canvas.width / ratio;\n      var maxY = this.canvas.height / ratio;\n      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n      svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n      svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n      svg.setAttribute('viewBox', \"\".concat(minX, \" \").concat(minY, \" \").concat(maxX, \" \").concat(maxY));\n      svg.setAttribute('width', maxX.toString());\n      svg.setAttribute('height', maxY.toString());\n      if (includeBackgroundColor && this.backgroundColor) {\n        var rect = document.createElement('rect');\n        rect.setAttribute('width', '100%');\n        rect.setAttribute('height', '100%');\n        rect.setAttribute('fill', this.backgroundColor);\n        svg.appendChild(rect);\n      }\n      this._fromData(pointGroups, function (curve, _ref3) {\n        var penColor = _ref3.penColor;\n        var path = document.createElement('path');\n        if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {\n          var attr = \"M \".concat(curve.startPoint.x.toFixed(3), \",\").concat(curve.startPoint.y.toFixed(3), \" \") + \"C \".concat(curve.control1.x.toFixed(3), \",\").concat(curve.control1.y.toFixed(3), \" \") + \"\".concat(curve.control2.x.toFixed(3), \",\").concat(curve.control2.y.toFixed(3), \" \") + \"\".concat(curve.endPoint.x.toFixed(3), \",\").concat(curve.endPoint.y.toFixed(3));\n          path.setAttribute('d', attr);\n          path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n          path.setAttribute('stroke', penColor);\n          path.setAttribute('fill', 'none');\n          path.setAttribute('stroke-linecap', 'round');\n          svg.appendChild(path);\n        }\n      }, function (point, _ref4) {\n        var penColor = _ref4.penColor,\n          dotSize = _ref4.dotSize,\n          minWidth = _ref4.minWidth,\n          maxWidth = _ref4.maxWidth;\n        var circle = document.createElement('circle');\n        var size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;\n        circle.setAttribute('r', size.toString());\n        circle.setAttribute('cx', point.x.toString());\n        circle.setAttribute('cy', point.y.toString());\n        circle.setAttribute('fill', penColor);\n        svg.appendChild(circle);\n      });\n      return svg.outerHTML;\n    }\n  }]);\n  return SignaturePad;\n}(SignatureEventTarget);\nexport { SignaturePad as default };","map":{"version":3,"sources":["../src/point.ts","../src/bezier.ts","../src/signature_event_target.ts","../src/throttle.ts","../src/signature_pad.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Signature Pad v4.1.4 | https://github.com/szimek/signature_pad\n * (c) 2022 Szymon Nowak | Released under the MIT license\n */\n\nclass Point {\n    constructor(x, y, pressure, time) {\n        if (isNaN(x) || isNaN(y)) {\n            throw new Error(`Point is invalid: (${x}, ${y})`);\n        }\n        this.x = +x;\n        this.y = +y;\n        this.pressure = pressure || 0;\n        this.time = time || Date.now();\n    }\n    distanceTo(start) {\n        return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n    }\n    equals(other) {\n        return (this.x === other.x &&\n            this.y === other.y &&\n            this.pressure === other.pressure &&\n            this.time === other.time);\n    }\n    velocityFrom(start) {\n        return this.time !== start.time\n            ? this.distanceTo(start) / (this.time - start.time)\n            : 0;\n    }\n}\n\nclass Bezier {\n    constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n        this.startPoint = startPoint;\n        this.control2 = control2;\n        this.control1 = control1;\n        this.endPoint = endPoint;\n        this.startWidth = startWidth;\n        this.endWidth = endWidth;\n    }\n    static fromPoints(points, widths) {\n        const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n        const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n        return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n    }\n    static calculateControlPoints(s1, s2, s3) {\n        const dx1 = s1.x - s2.x;\n        const dy1 = s1.y - s2.y;\n        const dx2 = s2.x - s3.x;\n        const dy2 = s2.y - s3.y;\n        const m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n        const m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n        const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n        const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n        const dxm = m1.x - m2.x;\n        const dym = m1.y - m2.y;\n        const k = l2 / (l1 + l2);\n        const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n        const tx = s2.x - cm.x;\n        const ty = s2.y - cm.y;\n        return {\n            c1: new Point(m1.x + tx, m1.y + ty),\n            c2: new Point(m2.x + tx, m2.y + ty),\n        };\n    }\n    length() {\n        const steps = 10;\n        let length = 0;\n        let px;\n        let py;\n        for (let i = 0; i <= steps; i += 1) {\n            const t = i / steps;\n            const cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n            const cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n            if (i > 0) {\n                const xdiff = cx - px;\n                const ydiff = cy - py;\n                length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n            }\n            px = cx;\n            py = cy;\n        }\n        return length;\n    }\n    point(t, start, c1, c2, end) {\n        return (start * (1.0 - t) * (1.0 - t) * (1.0 - t))\n            + (3.0 * c1 * (1.0 - t) * (1.0 - t) * t)\n            + (3.0 * c2 * (1.0 - t) * t * t)\n            + (end * t * t * t);\n    }\n}\n\nclass SignatureEventTarget {\n    constructor() {\n        try {\n            this._et = new EventTarget();\n        }\n        catch (error) {\n            this._et = document;\n        }\n    }\n    addEventListener(type, listener, options) {\n        this._et.addEventListener(type, listener, options);\n    }\n    dispatchEvent(event) {\n        return this._et.dispatchEvent(event);\n    }\n    removeEventListener(type, callback, options) {\n        this._et.removeEventListener(type, callback, options);\n    }\n}\n\nfunction throttle(fn, wait = 250) {\n    let previous = 0;\n    let timeout = null;\n    let result;\n    let storedContext;\n    let storedArgs;\n    const later = () => {\n        previous = Date.now();\n        timeout = null;\n        result = fn.apply(storedContext, storedArgs);\n        if (!timeout) {\n            storedContext = null;\n            storedArgs = [];\n        }\n    };\n    return function wrapper(...args) {\n        const now = Date.now();\n        const remaining = wait - (now - previous);\n        storedContext = this;\n        storedArgs = args;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            result = fn.apply(storedContext, storedArgs);\n            if (!timeout) {\n                storedContext = null;\n                storedArgs = [];\n            }\n        }\n        else if (!timeout) {\n            timeout = window.setTimeout(later, remaining);\n        }\n        return result;\n    };\n}\n\nclass SignaturePad extends SignatureEventTarget {\n    constructor(canvas, options = {}) {\n        super();\n        this.canvas = canvas;\n        this._handleMouseDown = (event) => {\n            if (event.buttons === 1) {\n                this._drawningStroke = true;\n                this._strokeBegin(event);\n            }\n        };\n        this._handleMouseMove = (event) => {\n            if (this._drawningStroke) {\n                this._strokeMoveUpdate(event);\n            }\n        };\n        this._handleMouseUp = (event) => {\n            if (event.buttons === 1 && this._drawningStroke) {\n                this._drawningStroke = false;\n                this._strokeEnd(event);\n            }\n        };\n        this._handleTouchStart = (event) => {\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            if (event.targetTouches.length === 1) {\n                const touch = event.changedTouches[0];\n                this._strokeBegin(touch);\n            }\n        };\n        this._handleTouchMove = (event) => {\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            const touch = event.targetTouches[0];\n            this._strokeMoveUpdate(touch);\n        };\n        this._handleTouchEnd = (event) => {\n            const wasCanvasTouched = event.target === this.canvas;\n            if (wasCanvasTouched) {\n                if (event.cancelable) {\n                    event.preventDefault();\n                }\n                const touch = event.changedTouches[0];\n                this._strokeEnd(touch);\n            }\n        };\n        this._handlePointerStart = (event) => {\n            this._drawningStroke = true;\n            event.preventDefault();\n            this._strokeBegin(event);\n        };\n        this._handlePointerMove = (event) => {\n            if (this._drawningStroke) {\n                event.preventDefault();\n                this._strokeMoveUpdate(event);\n            }\n        };\n        this._handlePointerEnd = (event) => {\n            if (this._drawningStroke) {\n                event.preventDefault();\n                this._drawningStroke = false;\n                this._strokeEnd(event);\n            }\n        };\n        this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n        this.minWidth = options.minWidth || 0.5;\n        this.maxWidth = options.maxWidth || 2.5;\n        this.throttle = ('throttle' in options ? options.throttle : 16);\n        this.minDistance = ('minDistance' in options ? options.minDistance : 5);\n        this.dotSize = options.dotSize || 0;\n        this.penColor = options.penColor || 'black';\n        this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';\n        this._strokeMoveUpdate = this.throttle\n            ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle)\n            : SignaturePad.prototype._strokeUpdate;\n        this._ctx = canvas.getContext('2d');\n        this.clear();\n        this.on();\n    }\n    clear() {\n        const { _ctx: ctx, canvas } = this;\n        ctx.fillStyle = this.backgroundColor;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        this._data = [];\n        this._reset(this._getPointGroupOptions());\n        this._isEmpty = true;\n    }\n    fromDataURL(dataUrl, options = {}) {\n        return new Promise((resolve, reject) => {\n            const image = new Image();\n            const ratio = options.ratio || window.devicePixelRatio || 1;\n            const width = options.width || this.canvas.width / ratio;\n            const height = options.height || this.canvas.height / ratio;\n            const xOffset = options.xOffset || 0;\n            const yOffset = options.yOffset || 0;\n            this._reset(this._getPointGroupOptions());\n            image.onload = () => {\n                this._ctx.drawImage(image, xOffset, yOffset, width, height);\n                resolve();\n            };\n            image.onerror = (error) => {\n                reject(error);\n            };\n            image.crossOrigin = 'anonymous';\n            image.src = dataUrl;\n            this._isEmpty = false;\n        });\n    }\n    toDataURL(type = 'image/png', encoderOptions) {\n        switch (type) {\n            case 'image/svg+xml':\n                if (typeof encoderOptions !== 'object') {\n                    encoderOptions = undefined;\n                }\n                return `data:image/svg+xml;base64,${btoa(this.toSVG(encoderOptions))}`;\n            default:\n                if (typeof encoderOptions !== 'number') {\n                    encoderOptions = undefined;\n                }\n                return this.canvas.toDataURL(type, encoderOptions);\n        }\n    }\n    on() {\n        this.canvas.style.touchAction = 'none';\n        this.canvas.style.msTouchAction = 'none';\n        this.canvas.style.userSelect = 'none';\n        const isIOS = /Macintosh/.test(navigator.userAgent) && 'ontouchstart' in document;\n        if (window.PointerEvent && !isIOS) {\n            this._handlePointerEvents();\n        }\n        else {\n            this._handleMouseEvents();\n            if ('ontouchstart' in window) {\n                this._handleTouchEvents();\n            }\n        }\n    }\n    off() {\n        this.canvas.style.touchAction = 'auto';\n        this.canvas.style.msTouchAction = 'auto';\n        this.canvas.style.userSelect = 'auto';\n        this.canvas.removeEventListener('pointerdown', this._handlePointerStart);\n        this.canvas.removeEventListener('pointermove', this._handlePointerMove);\n        this.canvas.ownerDocument.removeEventListener('pointerup', this._handlePointerEnd);\n        this.canvas.removeEventListener('mousedown', this._handleMouseDown);\n        this.canvas.removeEventListener('mousemove', this._handleMouseMove);\n        this.canvas.ownerDocument.removeEventListener('mouseup', this._handleMouseUp);\n        this.canvas.removeEventListener('touchstart', this._handleTouchStart);\n        this.canvas.removeEventListener('touchmove', this._handleTouchMove);\n        this.canvas.removeEventListener('touchend', this._handleTouchEnd);\n    }\n    isEmpty() {\n        return this._isEmpty;\n    }\n    fromData(pointGroups, { clear = true } = {}) {\n        if (clear) {\n            this.clear();\n        }\n        this._fromData(pointGroups, this._drawCurve.bind(this), this._drawDot.bind(this));\n        this._data = this._data.concat(pointGroups);\n    }\n    toData() {\n        return this._data;\n    }\n    _getPointGroupOptions(group) {\n        return {\n            penColor: group && 'penColor' in group ? group.penColor : this.penColor,\n            dotSize: group && 'dotSize' in group ? group.dotSize : this.dotSize,\n            minWidth: group && 'minWidth' in group ? group.minWidth : this.minWidth,\n            maxWidth: group && 'maxWidth' in group ? group.maxWidth : this.maxWidth,\n            velocityFilterWeight: group && 'velocityFilterWeight' in group\n                ? group.velocityFilterWeight\n                : this.velocityFilterWeight,\n        };\n    }\n    _strokeBegin(event) {\n        this.dispatchEvent(new CustomEvent('beginStroke', { detail: event }));\n        const pointGroupOptions = this._getPointGroupOptions();\n        const newPointGroup = Object.assign(Object.assign({}, pointGroupOptions), { points: [] });\n        this._data.push(newPointGroup);\n        this._reset(pointGroupOptions);\n        this._strokeUpdate(event);\n    }\n    _strokeUpdate(event) {\n        if (this._data.length === 0) {\n            this._strokeBegin(event);\n            return;\n        }\n        this.dispatchEvent(new CustomEvent('beforeUpdateStroke', { detail: event }));\n        const x = event.clientX;\n        const y = event.clientY;\n        const pressure = event.pressure !== undefined\n            ? event.pressure\n            : event.force !== undefined\n                ? event.force\n                : 0;\n        const point = this._createPoint(x, y, pressure);\n        const lastPointGroup = this._data[this._data.length - 1];\n        const lastPoints = lastPointGroup.points;\n        const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n        const isLastPointTooClose = lastPoint\n            ? point.distanceTo(lastPoint) <= this.minDistance\n            : false;\n        const pointGroupOptions = this._getPointGroupOptions(lastPointGroup);\n        if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n            const curve = this._addPoint(point, pointGroupOptions);\n            if (!lastPoint) {\n                this._drawDot(point, pointGroupOptions);\n            }\n            else if (curve) {\n                this._drawCurve(curve, pointGroupOptions);\n            }\n            lastPoints.push({\n                time: point.time,\n                x: point.x,\n                y: point.y,\n                pressure: point.pressure,\n            });\n        }\n        this.dispatchEvent(new CustomEvent('afterUpdateStroke', { detail: event }));\n    }\n    _strokeEnd(event) {\n        this._strokeUpdate(event);\n        this.dispatchEvent(new CustomEvent('endStroke', { detail: event }));\n    }\n    _handlePointerEvents() {\n        this._drawningStroke = false;\n        this.canvas.addEventListener('pointerdown', this._handlePointerStart);\n        this.canvas.addEventListener('pointermove', this._handlePointerMove);\n        this.canvas.ownerDocument.addEventListener('pointerup', this._handlePointerEnd);\n    }\n    _handleMouseEvents() {\n        this._drawningStroke = false;\n        this.canvas.addEventListener('mousedown', this._handleMouseDown);\n        this.canvas.addEventListener('mousemove', this._handleMouseMove);\n        this.canvas.ownerDocument.addEventListener('mouseup', this._handleMouseUp);\n    }\n    _handleTouchEvents() {\n        this.canvas.addEventListener('touchstart', this._handleTouchStart);\n        this.canvas.addEventListener('touchmove', this._handleTouchMove);\n        this.canvas.addEventListener('touchend', this._handleTouchEnd);\n    }\n    _reset(options) {\n        this._lastPoints = [];\n        this._lastVelocity = 0;\n        this._lastWidth = (options.minWidth + options.maxWidth) / 2;\n        this._ctx.fillStyle = options.penColor;\n    }\n    _createPoint(x, y, pressure) {\n        const rect = this.canvas.getBoundingClientRect();\n        return new Point(x - rect.left, y - rect.top, pressure, new Date().getTime());\n    }\n    _addPoint(point, options) {\n        const { _lastPoints } = this;\n        _lastPoints.push(point);\n        if (_lastPoints.length > 2) {\n            if (_lastPoints.length === 3) {\n                _lastPoints.unshift(_lastPoints[0]);\n            }\n            const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2], options);\n            const curve = Bezier.fromPoints(_lastPoints, widths);\n            _lastPoints.shift();\n            return curve;\n        }\n        return null;\n    }\n    _calculateCurveWidths(startPoint, endPoint, options) {\n        const velocity = options.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\n            (1 - options.velocityFilterWeight) * this._lastVelocity;\n        const newWidth = this._strokeWidth(velocity, options);\n        const widths = {\n            end: newWidth,\n            start: this._lastWidth,\n        };\n        this._lastVelocity = velocity;\n        this._lastWidth = newWidth;\n        return widths;\n    }\n    _strokeWidth(velocity, options) {\n        return Math.max(options.maxWidth / (velocity + 1), options.minWidth);\n    }\n    _drawCurveSegment(x, y, width) {\n        const ctx = this._ctx;\n        ctx.moveTo(x, y);\n        ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n        this._isEmpty = false;\n    }\n    _drawCurve(curve, options) {\n        const ctx = this._ctx;\n        const widthDelta = curve.endWidth - curve.startWidth;\n        const drawSteps = Math.ceil(curve.length()) * 2;\n        ctx.beginPath();\n        ctx.fillStyle = options.penColor;\n        for (let i = 0; i < drawSteps; i += 1) {\n            const t = i / drawSteps;\n            const tt = t * t;\n            const ttt = tt * t;\n            const u = 1 - t;\n            const uu = u * u;\n            const uuu = uu * u;\n            let x = uuu * curve.startPoint.x;\n            x += 3 * uu * t * curve.control1.x;\n            x += 3 * u * tt * curve.control2.x;\n            x += ttt * curve.endPoint.x;\n            let y = uuu * curve.startPoint.y;\n            y += 3 * uu * t * curve.control1.y;\n            y += 3 * u * tt * curve.control2.y;\n            y += ttt * curve.endPoint.y;\n            const width = Math.min(curve.startWidth + ttt * widthDelta, options.maxWidth);\n            this._drawCurveSegment(x, y, width);\n        }\n        ctx.closePath();\n        ctx.fill();\n    }\n    _drawDot(point, options) {\n        const ctx = this._ctx;\n        const width = options.dotSize > 0\n            ? options.dotSize\n            : (options.minWidth + options.maxWidth) / 2;\n        ctx.beginPath();\n        this._drawCurveSegment(point.x, point.y, width);\n        ctx.closePath();\n        ctx.fillStyle = options.penColor;\n        ctx.fill();\n    }\n    _fromData(pointGroups, drawCurve, drawDot) {\n        for (const group of pointGroups) {\n            const { points } = group;\n            const pointGroupOptions = this._getPointGroupOptions(group);\n            if (points.length > 1) {\n                for (let j = 0; j < points.length; j += 1) {\n                    const basicPoint = points[j];\n                    const point = new Point(basicPoint.x, basicPoint.y, basicPoint.pressure, basicPoint.time);\n                    if (j === 0) {\n                        this._reset(pointGroupOptions);\n                    }\n                    const curve = this._addPoint(point, pointGroupOptions);\n                    if (curve) {\n                        drawCurve(curve, pointGroupOptions);\n                    }\n                }\n            }\n            else {\n                this._reset(pointGroupOptions);\n                drawDot(points[0], pointGroupOptions);\n            }\n        }\n    }\n    toSVG({ includeBackgroundColor = false } = {}) {\n        const pointGroups = this._data;\n        const ratio = Math.max(window.devicePixelRatio || 1, 1);\n        const minX = 0;\n        const minY = 0;\n        const maxX = this.canvas.width / ratio;\n        const maxY = this.canvas.height / ratio;\n        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n        svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n        svg.setAttribute('viewBox', `${minX} ${minY} ${maxX} ${maxY}`);\n        svg.setAttribute('width', maxX.toString());\n        svg.setAttribute('height', maxY.toString());\n        if (includeBackgroundColor && this.backgroundColor) {\n            const rect = document.createElement('rect');\n            rect.setAttribute('width', '100%');\n            rect.setAttribute('height', '100%');\n            rect.setAttribute('fill', this.backgroundColor);\n            svg.appendChild(rect);\n        }\n        this._fromData(pointGroups, (curve, { penColor }) => {\n            const path = document.createElement('path');\n            if (!isNaN(curve.control1.x) &&\n                !isNaN(curve.control1.y) &&\n                !isNaN(curve.control2.x) &&\n                !isNaN(curve.control2.y)) {\n                const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} ` +\n                    `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ` +\n                    `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ` +\n                    `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;\n                path.setAttribute('d', attr);\n                path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));\n                path.setAttribute('stroke', penColor);\n                path.setAttribute('fill', 'none');\n                path.setAttribute('stroke-linecap', 'round');\n                svg.appendChild(path);\n            }\n        }, (point, { penColor, dotSize, minWidth, maxWidth }) => {\n            const circle = document.createElement('circle');\n            const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;\n            circle.setAttribute('r', size.toString());\n            circle.setAttribute('cx', point.x.toString());\n            circle.setAttribute('cy', point.y.toString());\n            circle.setAttribute('fill', penColor);\n            svg.appendChild(circle);\n        });\n        return svg.outerHTML;\n    }\n}\n\nexport { SignaturePad as default };\n//# sourceMappingURL=signature_pad.js.map\n"]},"metadata":{},"sourceType":"module"}