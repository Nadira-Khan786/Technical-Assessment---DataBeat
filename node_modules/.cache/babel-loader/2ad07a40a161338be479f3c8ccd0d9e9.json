{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.autocomplete = factory());\n})(this, function () {\n  'use strict';\n\n  /*\r\n   * https://github.com/kraaden/autocomplete\r\n   * Copyright (c) 2016 Denys Krasnoshchok\r\n   * MIT License\r\n   */\n  function autocomplete(settings) {\n    // just an alias to minimize JS file size\n    var doc = document;\n    var container = settings.container || doc.createElement(\"div\");\n    var containerStyle = container.style;\n    var userAgent = navigator.userAgent;\n    var mobileFirefox = ~userAgent.indexOf(\"Firefox\") && ~userAgent.indexOf(\"Mobile\");\n    var debounceWaitMs = settings.debounceWaitMs || 0;\n    var preventSubmit = settings.preventSubmit || false;\n    var disableAutoSelect = settings.disableAutoSelect || false;\n    // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead\n    var keyUpEventName = mobileFirefox ? \"input\" : \"keyup\";\n    var items = [];\n    var inputValue = \"\";\n    var minLen = 2;\n    var showOnFocus = settings.showOnFocus;\n    var selected;\n    var keypressCounter = 0;\n    var debounceTimer;\n    if (settings.minLength !== undefined) {\n      minLen = settings.minLength;\n    }\n    if (!settings.input) {\n      throw new Error(\"input undefined\");\n    }\n    var input = settings.input;\n    container.className = \"autocomplete \" + (settings.className || \"\");\n    // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning\n    containerStyle.position = \"absolute\";\n    /**\r\n     * Detach the container from DOM\r\n     */\n    function detach() {\n      var parent = container.parentNode;\n      if (parent) {\n        parent.removeChild(container);\n      }\n    }\n    /**\r\n     * Clear debouncing timer if assigned\r\n     */\n    function clearDebounceTimer() {\n      if (debounceTimer) {\n        window.clearTimeout(debounceTimer);\n      }\n    }\n    /**\r\n     * Attach the container to DOM\r\n     */\n    function attach() {\n      if (!container.parentNode) {\n        doc.body.appendChild(container);\n      }\n    }\n    /**\r\n     * Check if container for autocomplete is displayed\r\n     */\n    function containerDisplayed() {\n      return !!container.parentNode;\n    }\n    /**\r\n     * Clear autocomplete state and hide container\r\n     */\n    function clear() {\n      // prevent the update call if there are pending AJAX requests\n      keypressCounter++;\n      items = [];\n      inputValue = \"\";\n      selected = undefined;\n      detach();\n    }\n    /**\r\n     * Update autocomplete position\r\n     */\n    function updatePosition() {\n      if (!containerDisplayed()) {\n        return;\n      }\n      containerStyle.height = \"auto\";\n      containerStyle.width = input.offsetWidth + \"px\";\n      var maxHeight = 0;\n      var inputRect;\n      function calc() {\n        var docEl = doc.documentElement;\n        var clientTop = docEl.clientTop || doc.body.clientTop || 0;\n        var clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;\n        var scrollTop = window.pageYOffset || docEl.scrollTop;\n        var scrollLeft = window.pageXOffset || docEl.scrollLeft;\n        inputRect = input.getBoundingClientRect();\n        var top = inputRect.top + input.offsetHeight + scrollTop - clientTop;\n        var left = inputRect.left + scrollLeft - clientLeft;\n        containerStyle.top = top + \"px\";\n        containerStyle.left = left + \"px\";\n        maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);\n        if (maxHeight < 0) {\n          maxHeight = 0;\n        }\n        containerStyle.top = top + \"px\";\n        containerStyle.bottom = \"\";\n        containerStyle.left = left + \"px\";\n        containerStyle.maxHeight = maxHeight + \"px\";\n      }\n      // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)\n      calc();\n      calc();\n      if (settings.customize && inputRect) {\n        settings.customize(input, inputRect, container, maxHeight);\n      }\n    }\n    /**\r\n     * Redraw the autocomplete div element with suggestions\r\n     */\n    function update() {\n      // delete all children from autocomplete DOM container\n      while (container.firstChild) {\n        container.removeChild(container.firstChild);\n      }\n      // function for rendering autocomplete suggestions\n      var render = function render(item, currentValue) {\n        var itemElement = doc.createElement(\"div\");\n        itemElement.textContent = item.label || \"\";\n        return itemElement;\n      };\n      if (settings.render) {\n        render = settings.render;\n      }\n      // function to render autocomplete groups\n      var renderGroup = function renderGroup(groupName, currentValue) {\n        var groupDiv = doc.createElement(\"div\");\n        groupDiv.textContent = groupName;\n        return groupDiv;\n      };\n      if (settings.renderGroup) {\n        renderGroup = settings.renderGroup;\n      }\n      var fragment = doc.createDocumentFragment();\n      var prevGroup = \"#9?$\";\n      items.forEach(function (item) {\n        if (item.group && item.group !== prevGroup) {\n          prevGroup = item.group;\n          var groupDiv = renderGroup(item.group, inputValue);\n          if (groupDiv) {\n            groupDiv.className += \" group\";\n            fragment.appendChild(groupDiv);\n          }\n        }\n        var div = render(item, inputValue);\n        if (div) {\n          div.addEventListener(\"click\", function (ev) {\n            settings.onSelect(item, input);\n            clear();\n            ev.preventDefault();\n            ev.stopPropagation();\n          });\n          if (item === selected) {\n            div.className += \" selected\";\n          }\n          fragment.appendChild(div);\n        }\n      });\n      container.appendChild(fragment);\n      if (items.length < 1) {\n        if (settings.emptyMsg) {\n          var empty = doc.createElement(\"div\");\n          empty.className = \"empty\";\n          empty.textContent = settings.emptyMsg;\n          container.appendChild(empty);\n        } else {\n          clear();\n          return;\n        }\n      }\n      attach();\n      updatePosition();\n      updateScroll();\n    }\n    function updateIfDisplayed() {\n      if (containerDisplayed()) {\n        update();\n      }\n    }\n    function resizeEventHandler() {\n      updateIfDisplayed();\n    }\n    function scrollEventHandler(e) {\n      if (e.target !== container) {\n        updateIfDisplayed();\n      } else {\n        e.preventDefault();\n      }\n    }\n    function keyupEventHandler(ev) {\n      var keyCode = ev.which || ev.keyCode || 0;\n      var ignore = settings.keysToIgnore || [38 /* Up */, 13 /* Enter */, 27 /* Esc */, 39 /* Right */, 37 /* Left */, 16 /* Shift */, 17 /* Ctrl */, 18 /* Alt */, 20 /* CapsLock */, 91 /* WindowsKey */, 9 /* Tab */];\n      for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {\n        var key = ignore_1[_i];\n        if (keyCode === key) {\n          return;\n        }\n      }\n      if (keyCode >= 112 /* F1 */ && keyCode <= 123 /* F12 */ && !settings.keysToIgnore) {\n        return;\n      }\n      // the down key is used to open autocomplete\n      if (keyCode === 40 /* Down */ && containerDisplayed()) {\n        return;\n      }\n      startFetch(0 /* Keyboard */);\n    }\n    /**\r\n     * Automatically move scroll bar if selected item is not visible\r\n     */\n    function updateScroll() {\n      var elements = container.getElementsByClassName(\"selected\");\n      if (elements.length > 0) {\n        var element = elements[0];\n        // make group visible\n        var previous = element.previousElementSibling;\n        if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\n          element = previous;\n        }\n        if (element.offsetTop < container.scrollTop) {\n          container.scrollTop = element.offsetTop;\n        } else {\n          var selectBottom = element.offsetTop + element.offsetHeight;\n          var containerBottom = container.scrollTop + container.offsetHeight;\n          if (selectBottom > containerBottom) {\n            container.scrollTop += selectBottom - containerBottom;\n          }\n        }\n      }\n    }\n    /**\r\n     * Select the previous item in suggestions\r\n     */\n    function selectPrev() {\n      if (items.length < 1) {\n        selected = undefined;\n      } else {\n        if (selected === items[0]) {\n          selected = items[items.length - 1];\n        } else {\n          for (var i = items.length - 1; i > 0; i--) {\n            if (selected === items[i] || i === 1) {\n              selected = items[i - 1];\n              break;\n            }\n          }\n        }\n      }\n    }\n    /**\r\n     * Select the next item in suggestions\r\n     */\n    function selectNext() {\n      if (items.length < 1) {\n        selected = undefined;\n      }\n      if (!selected || selected === items[items.length - 1]) {\n        selected = items[0];\n        return;\n      }\n      for (var i = 0; i < items.length - 1; i++) {\n        if (selected === items[i]) {\n          selected = items[i + 1];\n          break;\n        }\n      }\n    }\n    function keydownEventHandler(ev) {\n      var keyCode = ev.which || ev.keyCode || 0;\n      if (keyCode === 38 /* Up */ || keyCode === 40 /* Down */ || keyCode === 27 /* Esc */) {\n        var containerIsDisplayed = containerDisplayed();\n        if (keyCode === 27 /* Esc */) {\n          clear();\n        } else {\n          if (!containerIsDisplayed || items.length < 1) {\n            return;\n          }\n          keyCode === 38 /* Up */ ? selectPrev() : selectNext();\n          update();\n        }\n        ev.preventDefault();\n        if (containerIsDisplayed) {\n          ev.stopPropagation();\n        }\n        return;\n      }\n      if (keyCode === 13 /* Enter */) {\n        if (selected) {\n          settings.onSelect(selected, input);\n          clear();\n        }\n        if (preventSubmit) {\n          ev.preventDefault();\n        }\n      }\n    }\n    function focusEventHandler() {\n      if (showOnFocus) {\n        startFetch(1 /* Focus */);\n      }\n    }\n\n    function startFetch(trigger) {\n      // If multiple keys were pressed, before we get an update from server,\n      // this may cause redrawing autocomplete multiple times after the last key was pressed.\n      // To avoid this, the number of times keyboard was pressed will be saved and checked before redraw.\n      var savedKeypressCounter = ++keypressCounter;\n      var inputText = input.value;\n      var cursorPos = input.selectionStart || 0;\n      if (inputText.length >= minLen || trigger === 1 /* Focus */) {\n        clearDebounceTimer();\n        debounceTimer = window.setTimeout(function () {\n          settings.fetch(inputText, function (elements) {\n            if (keypressCounter === savedKeypressCounter && elements) {\n              items = elements;\n              inputValue = inputText;\n              selected = items.length < 1 || disableAutoSelect ? undefined : items[0];\n              update();\n            }\n          }, trigger, cursorPos);\n        }, trigger === 0 /* Keyboard */ ? debounceWaitMs : 0);\n      } else {\n        clear();\n      }\n    }\n    function blurEventHandler() {\n      // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\n      setTimeout(function () {\n        if (doc.activeElement !== input) {\n          clear();\n        }\n      }, 200);\n    }\n    /**\r\n     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called\r\n     */\n    container.addEventListener(\"mousedown\", function (evt) {\n      evt.stopPropagation();\n      evt.preventDefault();\n    });\n    /**\r\n     * Fixes #30: autocomplete closes when scrollbar is clicked in IE\r\n     * See: https://stackoverflow.com/a/9210267/13172349\r\n     */\n    container.addEventListener(\"focus\", function () {\n      return input.focus();\n    });\n    /**\r\n     * This function will remove DOM elements and clear event handlers\r\n     */\n    function destroy() {\n      input.removeEventListener(\"focus\", focusEventHandler);\n      input.removeEventListener(\"keydown\", keydownEventHandler);\n      input.removeEventListener(keyUpEventName, keyupEventHandler);\n      input.removeEventListener(\"blur\", blurEventHandler);\n      window.removeEventListener(\"resize\", resizeEventHandler);\n      doc.removeEventListener(\"scroll\", scrollEventHandler, true);\n      clearDebounceTimer();\n      clear();\n    }\n    // setup event handlers\n    input.addEventListener(\"keydown\", keydownEventHandler);\n    input.addEventListener(keyUpEventName, keyupEventHandler);\n    input.addEventListener(\"blur\", blurEventHandler);\n    input.addEventListener(\"focus\", focusEventHandler);\n    window.addEventListener(\"resize\", resizeEventHandler);\n    doc.addEventListener(\"scroll\", scrollEventHandler, true);\n    return {\n      destroy: destroy\n    };\n  }\n  return autocomplete;\n});","map":{"version":3,"sources":["autocomplete.ts"],"names":[],"mappings":"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","sourcesContent":[" /*\n  * https://github.com/kraaden/autocomplete\n  * Copyright (c) 2016 Denys Krasnoshchok\n  * MIT License\n  */\n\nexport const enum EventTrigger {\n    Keyboard = 0,\n    Focus = 1\n}\n\nexport interface AutocompleteItem {\n    label?: string;\n    group?: string;\n}\n\nexport interface AutocompleteSettings<T extends AutocompleteItem> {\n    /**\n     * Autocomplete will be attached to this element.\n     */\n    input: HTMLInputElement | HTMLTextAreaElement;\n\n    /**\n     * Provide your own container for the widget.\n     * If not specified, a new DIV element will be created.\n     */\n    container?: HTMLDivElement;\n\n    /**\n     * This method allows you to override the default rendering function for items.\n     * It must return a DIV element or undefined to skip rendering.\n     */\n    render?: (item: T, currentValue: string) => HTMLDivElement | undefined;\n\n    /**\n     * This method allows you to override the default rendering function for item groups.\n     * It must return a DIV element or undefined to skip rendering.\n     */\n    renderGroup?: (name: string, currentValue: string) => HTMLDivElement | undefined;\n\n    /**\n     * If specified, the autocomplete DOM element will have this class assigned to it.\n     */\n    className?: string;\n\n    /**\n     * Specify the minimum text length required to show autocomplete.\n     */\n    minLength?: number;\n\n    /**\n     * The message that will be showed when there are no suggestions that match the entered value.\n     */\n    emptyMsg?: string;\n\n    /**\n     * This method will be called when user choose an item in autocomplete. The selected item will be passed as the first parameter.\n     */\n    onSelect: (item: T, input: HTMLInputElement | HTMLTextAreaElement) => void;\n\n    /**\n     * Show autocomplete on focus event. Focus event will ignore the `minLength` property and will always call `fetch`.\n     */\n    showOnFocus?: boolean;\n\n    /**\n     * This method will be called to prepare suggestions and then pass them to autocomplete.\n     * @param {string} text - text in the input field\n     * @param {(items: T[] | false) => void} update - a callback function that must be called after suggestions are prepared\n     * @param {EventTrigger} trigger - type of the event that triggered the fetch\n     * @param {number} cursorPos - position of the cursor in the input field\n     */\n    fetch: (text: string, update: (items: T[] | false) => void, trigger: EventTrigger, cursorPos: number) => void;\n\n    /**\n     * Enforces that the fetch function will only be called once within the specified time frame (in milliseconds) and\n     * delays execution. This prevents flooding your server with AJAX requests.\n     */\n    debounceWaitMs?: number;\n\n    /**\n     * Callback for additional autocomplete customization\n     * @param {HTMLInputElement | HTMLTextAreaElement} input - input box associated with autocomplete\n     * @param {ClientRect | DOMRect} inputRect - size of the input box and its position relative to the viewport\n     * @param {HTMLDivElement} container - container with suggestions\n     * @param {number} maxHeight - max height that can be used by autocomplete\n     */\n    customize?: (input: HTMLInputElement | HTMLTextAreaElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\n\n    /**\n     * Prevents automatic form submit when ENTER is pressed\n     */\n    preventSubmit?: boolean;\n    \n    /**\n     * Prevents the first item in the list from being selected automatically. This option allows you\n     * to submit a custom text by pressing ENTER even when autocomplete is displayed.\n     */\n    disableAutoSelect?: boolean;\n\n    /**\n     * Keys that will be ignored and not trigger the fetch callback.\n     */\n    keysToIgnore?: Keys[];\n}\n\nexport interface AutocompleteResult {\n    destroy: () => void;\n}\n\nexport const enum Keys {\n    Enter = 13,\n    Esc = 27,\n    Up = 38,\n    Down = 40,\n    Left = 37,\n    Right = 39,\n    Shift = 16,\n    Ctrl = 17,\n    Alt = 18,\n    CapsLock = 20,\n    WindowsKey = 91,\n    Tab = 9,\n    F1 = 112,\n    F12 = 123\n}\n\nexport default function autocomplete<T extends AutocompleteItem>(settings: AutocompleteSettings<T>): AutocompleteResult {\n\n    // just an alias to minimize JS file size\n    const doc = document;\n\n    const container: HTMLDivElement = settings.container || doc.createElement(\"div\");\n    const containerStyle = container.style;\n    const userAgent = navigator.userAgent;\n    const mobileFirefox = ~userAgent.indexOf(\"Firefox\") && ~userAgent.indexOf(\"Mobile\");\n    const debounceWaitMs = settings.debounceWaitMs || 0;\n    const preventSubmit = settings.preventSubmit || false;\n    const disableAutoSelect = settings.disableAutoSelect || false;\n    \n    // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead\n    const keyUpEventName = mobileFirefox ? \"input\" : \"keyup\";\n    \n    let items: T[] = [];\n    let inputValue = \"\";\n    let minLen = 2;\n    const showOnFocus = settings.showOnFocus;\n    let selected: T | undefined;\n    let keypressCounter = 0;\n    let debounceTimer : number | undefined;\n\n    if (settings.minLength !== undefined) {\n        minLen = settings.minLength;\n    }\n\n    if (!settings.input) {\n        throw new Error(\"input undefined\");\n    }\n\n    const input: HTMLInputElement | HTMLTextAreaElement = settings.input;\n\n    container.className = \"autocomplete \" + (settings.className || \"\");\n\n    // IOS implementation for fixed positioning has many bugs, so we will use absolute positioning\n    containerStyle.position = \"absolute\";\n\n    /**\n     * Detach the container from DOM\n     */\n    function detach(): void {\n        const parent = container.parentNode;\n        if (parent) {\n            parent.removeChild(container);\n        }\n    }\n\n    /**\n     * Clear debouncing timer if assigned\n     */\n    function clearDebounceTimer(): void {\n        if (debounceTimer) {\n            window.clearTimeout(debounceTimer);\n        }\n    }\n\n    /**\n     * Attach the container to DOM\n     */\n    function attach(): void {\n        if (!container.parentNode) {\n            doc.body.appendChild(container);\n        }\n    }\n\n    /**\n     * Check if container for autocomplete is displayed\n     */\n    function containerDisplayed(): boolean {\n        return !!container.parentNode;\n    }\n\n    /**\n     * Clear autocomplete state and hide container\n     */\n    function clear(): void {\n        // prevent the update call if there are pending AJAX requests\n        keypressCounter++;\n        \n        items = [];\n        inputValue = \"\";\n        selected = undefined;\n        detach();\n    }\n\n    /**\n     * Update autocomplete position\n     */\n    function updatePosition(): void {\n        if (!containerDisplayed()) {\n            return;\n        }\n\n        containerStyle.height = \"auto\";\n        containerStyle.width = input.offsetWidth + \"px\";\n\n        let maxHeight = 0;\n        let inputRect: ClientRect | DOMRect | undefined;\n\n        function calc() {\n            const docEl = doc.documentElement as HTMLElement;\n            const clientTop = docEl.clientTop || doc.body.clientTop || 0;\n            const clientLeft = docEl.clientLeft || doc.body.clientLeft || 0;\n            const scrollTop = window.pageYOffset || docEl.scrollTop;\n            const scrollLeft = window.pageXOffset || docEl.scrollLeft;\n\n            inputRect = input.getBoundingClientRect();\n        \n            const top = inputRect.top + input.offsetHeight + scrollTop - clientTop;\n            const left = inputRect.left + scrollLeft - clientLeft;\n    \n            containerStyle.top = top + \"px\";\n            containerStyle.left = left + \"px\";\n    \n            maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);\n    \n            if (maxHeight < 0) {\n                maxHeight = 0;\n            }\n    \n            containerStyle.top = top + \"px\";\n            containerStyle.bottom = \"\";\n            containerStyle.left = left + \"px\";\n            containerStyle.maxHeight = maxHeight + \"px\";\n        }\n\n        // the calc method must be called twice, otherwise the calculation may be wrong on resize event (chrome browser)\n        calc();\n        calc();\n\n        if (settings.customize && inputRect) {\n            settings.customize(input, inputRect, container, maxHeight);\n        }\n    }\n\n    /**\n     * Redraw the autocomplete div element with suggestions\n     */\n    function update(): void {\n        \n        // delete all children from autocomplete DOM container\n        while (container.firstChild) {\n            container.removeChild(container.firstChild);\n        }\n\n        // function for rendering autocomplete suggestions\n        let render = function(item: T, currentValue: string): HTMLDivElement | undefined {\n            const itemElement = doc.createElement(\"div\");\n            itemElement.textContent = item.label || \"\";\n            return itemElement;\n        };\n        if (settings.render) {\n            render = settings.render;\n        }\n\n        // function to render autocomplete groups\n        let renderGroup = function(groupName: string, currentValue: string): HTMLDivElement | undefined {\n            const groupDiv = doc.createElement(\"div\");\n            groupDiv.textContent = groupName;\n            return groupDiv;\n        };\n        if (settings.renderGroup) {\n            renderGroup = settings.renderGroup;\n        }\n\n        const fragment = doc.createDocumentFragment();\n        let prevGroup = \"#9?$\";\n\n        items.forEach(function(item: T): void {\n            if (item.group && item.group !== prevGroup) {\n                prevGroup = item.group;\n                const groupDiv = renderGroup(item.group, inputValue);\n                if (groupDiv) {\n                    groupDiv.className += \" group\";\n                    fragment.appendChild(groupDiv);\n                }\n            }\n            const div = render(item, inputValue);\n            if (div) {\n                div.addEventListener(\"click\", function(ev: MouseEvent): void {\n                    settings.onSelect(item, input);\n                    clear();\n                    ev.preventDefault();\n                    ev.stopPropagation();\n                });\n                if (item === selected) {\n                    div.className += \" selected\";\n                }\n                fragment.appendChild(div);\n            }\n        });\n        container.appendChild(fragment);\n        if (items.length < 1) {\n            if (settings.emptyMsg) {\n                const empty = doc.createElement(\"div\");\n                empty.className = \"empty\";\n                empty.textContent = settings.emptyMsg;\n                container.appendChild(empty);\n            } else {\n                clear();\n                return;\n            }\n        }\n\n        attach();\n        updatePosition();\n\n        updateScroll();\n    }\n\n    function updateIfDisplayed(): void {\n        if (containerDisplayed()) {\n            update();\n        }\n    }\n\n    function resizeEventHandler(): void {\n        updateIfDisplayed();\n    }\n\n    function scrollEventHandler(e: Event): void {\n        if (e.target !== container) {\n            updateIfDisplayed();\n        } else {\n            e.preventDefault();\n        }\n    }\n\n    function keyupEventHandler(ev: KeyboardEvent): void {\n        const keyCode = ev.which || ev.keyCode || 0;\n\n        const ignore = settings.keysToIgnore || [Keys.Up, Keys.Enter, Keys.Esc, Keys.Right, Keys.Left, Keys.Shift, Keys.Ctrl, Keys.Alt, Keys.CapsLock, Keys.WindowsKey, Keys.Tab];\n        for (const key of ignore) {\n            if (keyCode === key) {\n                return;\n            }\n        }\n\n        if (keyCode >= Keys.F1 && keyCode <= Keys.F12 && !settings.keysToIgnore) {\n            return;\n        }\n\n        // the down key is used to open autocomplete\n        if (keyCode === Keys.Down && containerDisplayed()) {\n            return;\n        }\n\n        startFetch(EventTrigger.Keyboard);\n    }\n\n    /**\n     * Automatically move scroll bar if selected item is not visible\n     */\n    function updateScroll(): void {\n        const elements = container.getElementsByClassName(\"selected\");\n        if (elements.length > 0) {\n            let element = elements[0] as HTMLDivElement;\n            \n            // make group visible\n            const previous = element.previousElementSibling as HTMLDivElement;\n            if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\n                element = previous;\n            }\n\n            if (element.offsetTop < container.scrollTop) {\n                container.scrollTop = element.offsetTop;\n            } else {\n                const selectBottom = element.offsetTop + element.offsetHeight;\n                const containerBottom = container.scrollTop + container.offsetHeight;\n                if (selectBottom > containerBottom) {\n                    container.scrollTop += selectBottom - containerBottom;\n                }\n            }\n        }\n    }\n\n    /**\n     * Select the previous item in suggestions\n     */\n    function selectPrev(): void {\n        if (items.length < 1) {\n            selected = undefined;\n        } else {\n            if (selected === items[0]) {\n                selected = items[items.length - 1];\n            } else {\n                for (let i = items.length - 1; i > 0; i--) {\n                    if (selected === items[i] || i === 1) {\n                        selected = items[i - 1];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Select the next item in suggestions\n     */\n    function selectNext(): void {\n        if (items.length < 1) {\n            selected = undefined;\n        }\n        if (!selected || selected === items[items.length - 1]) {\n            selected = items[0];\n            return;\n        }\n        for (let i = 0; i < (items.length - 1); i++) {\n            if (selected === items[i]) {\n                selected = items[i + 1];\n                break;\n            }\n        }\n    }\n\n    function keydownEventHandler(ev: KeyboardEvent): void {\n        const keyCode = ev.which || ev.keyCode || 0;\n\n        if (keyCode === Keys.Up || keyCode === Keys.Down || keyCode === Keys.Esc) {\n            const containerIsDisplayed = containerDisplayed();\n\n            if (keyCode === Keys.Esc) {\n                clear();\n            } else {\n                if (!containerIsDisplayed || items.length < 1) {\n                    return;\n                }\n                keyCode === Keys.Up\n                    ? selectPrev()\n                    : selectNext();\n                update();\n            }\n\n            ev.preventDefault();\n            if (containerIsDisplayed) {\n                ev.stopPropagation();\n            }\n\n            return;\n        }\n\n        if (keyCode === Keys.Enter) {\n            if (selected) {\n                settings.onSelect(selected, input);\n                clear();\n            }\n    \n            if (preventSubmit) {\n                ev.preventDefault();\n            }\n        }\n    }\n\n    function focusEventHandler(): void {\n        if (showOnFocus) {\n            startFetch(EventTrigger.Focus);\n        }\n    }\n\n    function startFetch(trigger: EventTrigger) {\n        // If multiple keys were pressed, before we get an update from server,\n        // this may cause redrawing autocomplete multiple times after the last key was pressed.\n        // To avoid this, the number of times keyboard was pressed will be saved and checked before redraw.\n        const savedKeypressCounter = ++keypressCounter;\n\n        const inputText = input.value;\n        const cursorPos = input.selectionStart || 0;\n\n        if (inputText.length >= minLen || trigger === EventTrigger.Focus) {\n            clearDebounceTimer();\n            debounceTimer = window.setTimeout(function(): void {\n                settings.fetch(inputText, function(elements: T[] | false): void {\n                    if (keypressCounter === savedKeypressCounter && elements) {\n                        items = elements;\n                        inputValue = inputText;\n                        selected = (items.length < 1 || disableAutoSelect) ? undefined : items[0];\n                        update();\n                    }\n                }, trigger, cursorPos);\n            }, trigger === EventTrigger.Keyboard ? debounceWaitMs : 0);\n        } else {\n            clear();\n        }\n    }\n\n    function blurEventHandler(): void {\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\n        setTimeout(() => {\n            if (doc.activeElement !== input) {\n                clear();\n            }\n        }, 200);\n    }\n\n    /**\n     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called\n     */\n    container.addEventListener(\"mousedown\", function(evt: Event) {\n        evt.stopPropagation();\n        evt.preventDefault();\n    });\n\n    /**\n     * Fixes #30: autocomplete closes when scrollbar is clicked in IE\n     * See: https://stackoverflow.com/a/9210267/13172349\n     */\n    container.addEventListener(\"focus\", () => input.focus());\n\n    /**\n     * This function will remove DOM elements and clear event handlers\n     */\n    function destroy(): void {\n        input.removeEventListener(\"focus\", focusEventHandler);\n        input.removeEventListener(\"keydown\", keydownEventHandler as EventListenerOrEventListenerObject);\n        input.removeEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\n        input.removeEventListener(\"blur\", blurEventHandler);\n        window.removeEventListener(\"resize\", resizeEventHandler);\n        doc.removeEventListener(\"scroll\", scrollEventHandler, true);\n        clearDebounceTimer();\n        clear();\n    }\n\n    // setup event handlers\n    input.addEventListener(\"keydown\", keydownEventHandler as EventListenerOrEventListenerObject);\n    input.addEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\n    input.addEventListener(\"blur\", blurEventHandler);\n    input.addEventListener(\"focus\", focusEventHandler);\n    window.addEventListener(\"resize\", resizeEventHandler);\n    doc.addEventListener(\"scroll\", scrollEventHandler, true);\n\n    return {\n        destroy\n    };\n}\n"]},"metadata":{},"sourceType":"script"}