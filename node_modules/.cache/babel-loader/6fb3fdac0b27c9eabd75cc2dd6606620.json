{"ast":null,"code":"import _slicedToArray from \"D:/task/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nexport default function compareVersions(v1, v2) {\n  // validate input and split into segments\n  var n1 = validateAndParse(v1);\n  var n2 = validateAndParse(v2);\n\n  // pop off the patch\n  var p1 = n1.pop();\n  var p2 = n2.pop();\n\n  // validate numbers\n  var r = compareSegments(n1, n2);\n  if (r !== 0) return r;\n\n  // validate pre-release\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n  return 0;\n}\nexport var validate = function validate(v) {\n  return typeof v === 'string' && /^[v\\d]/.test(v) && semver.test(v);\n};\nexport var compare = function compare(v1, v2, operator) {\n  // validate input operator\n  assertValidOperator(operator);\n\n  // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n  var res = compareVersions(v1, v2);\n  return operatorResMap[operator].includes(res);\n};\nexport var satisfies = function satisfies(v, r) {\n  // if no range operator then \"=\"\n  var m = r.match(/^([<>=~^]+)/);\n  var op = m ? m[1] : '=';\n\n  // if gt/lt/eq then operator compare\n  if (op !== '^' && op !== '~') return compare(v, r, op);\n\n  // else range of either \"~\" or \"^\" is assumed\n  var _validateAndParse = validateAndParse(v),\n    _validateAndParse2 = _slicedToArray(_validateAndParse, 3),\n    v1 = _validateAndParse2[0],\n    v2 = _validateAndParse2[1],\n    v3 = _validateAndParse2[2];\n  var _validateAndParse3 = validateAndParse(r),\n    _validateAndParse4 = _slicedToArray(_validateAndParse3, 3),\n    r1 = _validateAndParse4[0],\n    r2 = _validateAndParse4[1],\n    r3 = _validateAndParse4[2];\n  if (compareStrings(v1, r1) !== 0) return false;\n  if (op === '^') {\n    return compareSegments([v2, v3], [r2, r3]) >= 0;\n  }\n  if (compareStrings(v2, r2) !== 0) return false;\n  return compareStrings(v3, r3) >= 0;\n};\n\n// export CJS style for parity\ncompareVersions.validate = validate;\ncompareVersions.compare = compare;\ncompareVersions.satisfies = satisfies;\nvar semver = /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\nvar validateAndParse = function validateAndParse(v) {\n  if (typeof v !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n  var match = v.match(semver);\n  if (!match) {\n    throw new Error(\"Invalid argument not valid semver ('\".concat(v, \"' received)\"));\n  }\n  match.shift();\n  return match;\n};\nvar isWildcard = function isWildcard(s) {\n  return s === '*' || s === 'x' || s === 'X';\n};\nvar tryParse = function tryParse(v) {\n  var n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\nvar forceType = function forceType(a, b) {\n  return typeof a !== typeof b ? [String(a), String(b)] : [a, b];\n};\nvar compareStrings = function compareStrings(a, b) {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n  var _forceType = forceType(tryParse(a), tryParse(b)),\n    _forceType2 = _slicedToArray(_forceType, 2),\n    ap = _forceType2[0],\n    bp = _forceType2[1];\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\nvar compareSegments = function compareSegments(a, b) {\n  for (var i = 0; i < Math.max(a.length, b.length); i++) {\n    var r = compareStrings(a[i] || 0, b[i] || 0);\n    if (r !== 0) return r;\n  }\n  return 0;\n};\nvar operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1]\n};\nvar allowedOperators = Object.keys(operatorResMap);\nvar assertValidOperator = function assertValidOperator(op) {\n  if (typeof op !== 'string') {\n    throw new TypeError(\"Invalid operator type, expected string but got \".concat(typeof op));\n  }\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(\"Invalid operator, expected one of \".concat(allowedOperators.join('|')));\n  }\n};","map":{"version":3,"names":["compareVersions","v1","v2","n1","validateAndParse","n2","p1","pop","p2","r","compareSegments","split","validate","v","test","semver","compare","operator","assertValidOperator","res","operatorResMap","includes","satisfies","m","match","op","v3","r1","r2","r3","compareStrings","TypeError","Error","shift","isWildcard","s","tryParse","n","parseInt","isNaN","forceType","a","b","String","ap","bp","i","Math","max","length","allowedOperators","Object","keys","indexOf","join"],"sources":["D:/task/node_modules/compare-versions/index.mjs"],"sourcesContent":["export default function compareVersions(v1, v2) {\n  // validate input and split into segments\n  const n1 = validateAndParse(v1);\n  const n2 = validateAndParse(v2);\n\n  // pop off the patch\n  const p1 = n1.pop();\n  const p2 = n2.pop();\n\n  // validate numbers\n  const r = compareSegments(n1, n2);\n  if (r !== 0) return r;\n\n  // validate pre-release\n  if (p1 && p2) {\n    return compareSegments(p1.split('.'), p2.split('.'));\n  } else if (p1 || p2) {\n    return p1 ? -1 : 1;\n  }\n\n  return 0;\n}\n\nexport const validate = (v) =>\n  typeof v === 'string' && /^[v\\d]/.test(v) && semver.test(v);\n\nexport const compare = (v1, v2, operator) => {\n  // validate input operator\n  assertValidOperator(operator);\n\n  // since result of compareVersions can only be -1 or 0 or 1\n  // a simple map can be used to replace switch\n  const res = compareVersions(v1, v2);\n\n  return operatorResMap[operator].includes(res);\n};\n\nexport const satisfies = (v, r) => {\n  // if no range operator then \"=\"\n  const m = r.match(/^([<>=~^]+)/);\n  const op = m ? m[1] : '=';\n\n  // if gt/lt/eq then operator compare\n  if (op !== '^' && op !== '~') return compare(v, r, op);\n\n  // else range of either \"~\" or \"^\" is assumed\n  const [v1, v2, v3] = validateAndParse(v);\n  const [r1, r2, r3] = validateAndParse(r);\n  if (compareStrings(v1, r1) !== 0) return false;\n  if (op === '^') {\n    return compareSegments([v2, v3], [r2, r3]) >= 0;\n  }\n  if (compareStrings(v2, r2) !== 0) return false;\n  return compareStrings(v3, r3) >= 0;\n};\n\n// export CJS style for parity\ncompareVersions.validate = validate;\ncompareVersions.compare = compare;\ncompareVersions.satisfies = satisfies;\n\nconst semver =\n  /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\n\nconst validateAndParse = (v) => {\n  if (typeof v !== 'string') {\n    throw new TypeError('Invalid argument expected string');\n  }\n  const match = v.match(semver);\n  if (!match) {\n    throw new Error(`Invalid argument not valid semver ('${v}' received)`);\n  }\n  match.shift();\n  return match;\n};\n\nconst isWildcard = (s) => s === '*' || s === 'x' || s === 'X';\n\nconst tryParse = (v) => {\n  const n = parseInt(v, 10);\n  return isNaN(n) ? v : n;\n};\n\nconst forceType = (a, b) =>\n  typeof a !== typeof b ? [String(a), String(b)] : [a, b];\n\nconst compareStrings = (a, b) => {\n  if (isWildcard(a) || isWildcard(b)) return 0;\n  const [ap, bp] = forceType(tryParse(a), tryParse(b));\n  if (ap > bp) return 1;\n  if (ap < bp) return -1;\n  return 0;\n};\n\nconst compareSegments = (a, b) => {\n  for (let i = 0; i < Math.max(a.length, b.length); i++) {\n    const r = compareStrings(a[i] || 0, b[i] || 0);\n    if (r !== 0) return r;\n  }\n  return 0;\n};\n\nconst operatorResMap = {\n  '>': [1],\n  '>=': [0, 1],\n  '=': [0],\n  '<=': [-1, 0],\n  '<': [-1],\n};\n\nconst allowedOperators = Object.keys(operatorResMap);\n\nconst assertValidOperator = (op) => {\n  if (typeof op !== 'string') {\n    throw new TypeError(\n      `Invalid operator type, expected string but got ${typeof op}`\n    );\n  }\n  if (allowedOperators.indexOf(op) === -1) {\n    throw new Error(\n      `Invalid operator, expected one of ${allowedOperators.join('|')}`\n    );\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}